/**
 * Tubee API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: opensource@gyselroth.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessRole {
    'links'?: Links;
    'kind'?: string;
    'id'?: string;
    'name'?: string;
    'identifiers'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "identifiers",
            "baseName": "identifiers",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRole.attributeTypeMap;
    }
}

export class AccessRoles {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<AccessRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRole>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRoles.attributeTypeMap;
    }
}

export class AccessRule {
    'links'?: Links;
    'kind'?: string;
    'id'?: string;
    'name'?: string;
    'roles'?: Array<string>;
    'verbs'?: Array<string>;
    'selectors'?: Array<string>;
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        },
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<string>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRule.attributeTypeMap;
    }
}

export class AccessRules {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<AccessRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRule>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRules.attributeTypeMap;
    }
}

export class AttributeMap {
    'links'?: Links;
    'kind'?: string;
    'datatype'?: Datatype;
    'mandator'?: Mandator;
    'workflow'?: Workflow;
    /**
    * Name of implementation, usually Tubee\\AttributeMap
    */
    '_class'?: string;
    /**
    * Attribute map
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "Datatype"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AttributeMap.attributeTypeMap;
    }
}

export class Data {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Data.attributeTypeMap;
    }
}

export class Data1 {
    /**
    * Description
    */
    'descripiton'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Data1.attributeTypeMap;
    }
}

export class Data10 {
    /**
    * ObjectID to the object to refernece to
    */
    'relative': string;
    /**
    * Add context data which describes the relation
    */
    'context'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "relative",
            "baseName": "relative",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Data10.attributeTypeMap;
    }
}

export class Data11 {
    /**
    * Object attributes
    */
    'data': any;
    /**
    * Specify destination endpoints, if not set the objects get exported to all destination endpoints
    */
    'endpoints'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Data11.attributeTypeMap;
    }
}

export class Data2 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return Data2.attributeTypeMap;
    }
}

export class Data3 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return Data3.attributeTypeMap;
    }
}

export class Data4 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return Data4.attributeTypeMap;
    }
}

export class Data5 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return Data5.attributeTypeMap;
    }
}

export class Data6 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'map'?: AttributeMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "AttributeMap"
        }    ];

    static getAttributeTypeMap() {
        return Data6.attributeTypeMap;
    }
}

export class Data7 {
    /**
    * Name
    */
    'name': string;
    /**
    * Description
    */
    'descripiton'?: string;
    'map'?: AttributeMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "descripiton",
            "baseName": "descripiton",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "AttributeMap"
        }    ];

    static getAttributeTypeMap() {
        return Data7.attributeTypeMap;
    }
}

export class Data8 {
    /**
    * Object attributes
    */
    'data': any;
    /**
    * Specify destination endpoints, if not set the objects get exported to all destination endpoints
    */
    'endpoints'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Data8.attributeTypeMap;
    }
}

export class Data9 {
    /**
    * ObjectID to the object to refernece to
    */
    'relative': string;
    /**
    * Add context data which describes the relation
    */
    'context'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "relative",
            "baseName": "relative",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Data9.attributeTypeMap;
    }
}

export class DataObject {
    'links'?: ListLinks;
    'kind'?: string;
    'id'?: string;
    'version'?: number;
    'created'?: Date;
    'changed'?: Date;
    'deleted'?: Date;
    'mandator'?: string;
    'datatype'?: string;
    'locked'?: Date;
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "Date"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "Date"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "string"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "string"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "Date"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DataObject.attributeTypeMap;
    }
}

export class DataObjects {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<DataObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<DataObject>"
        }    ];

    static getAttributeTypeMap() {
        return DataObjects.attributeTypeMap;
    }
}

export class Datatype {
    'links'?: Links;
    'kind'?: string;
    /**
    * Datatype name
    */
    'name'?: string;
    'mandator'?: Mandator;
    /**
    * Is true if datatype is enabled
    */
    'enabled'?: boolean;
    /**
    * Name of implementation, usually Tubee\\Datatype
    */
    '_class'?: string;
    /**
    * Collection name which holds objects of this datatype
    */
    'collection'?: string;
    /**
    * Dataset aggregation query
    */
    'dataset'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "string"
        },
        {
            "name": "dataset",
            "baseName": "dataset",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Datatype.attributeTypeMap;
    }
}

export class Datatypes {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<Datatype>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Datatype>"
        }    ];

    static getAttributeTypeMap() {
        return Datatypes.attributeTypeMap;
    }
}

export class Endpoint {
    'links'?: Links;
    'kind'?: string;
    /**
    * Endpoint name
    */
    'name'?: string;
    'status'?: EndpointStatus;
    'datatype'?: Datatype;
    'mandator'?: Mandator;
    /**
    * Type of endpoint (Either source or destination)
    */
    'type'?: string;
    /**
    * Name of implementation (Endpoint type/protocol)
    */
    '_class'?: string;
    /**
    * Is true if history tracking is enabled to this endpoint
    */
    'history'?: boolean;
    /**
    * Array of attributes which are used as identifier
    */
    '_import'?: Array<string>;
    /**
    * Filter to identitfy exactly one object
    */
    'filterOne'?: string;
    /**
    * Filter whole endpoint
    */
    'filterAll'?: string;
    /**
    * Endpoint specific configuration
    */
    'resource'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "EndpointStatus"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "Datatype"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "history",
            "baseName": "history",
            "type": "boolean"
        },
        {
            "name": "_import",
            "baseName": "import",
            "type": "Array<string>"
        },
        {
            "name": "filterOne",
            "baseName": "filter_one",
            "type": "string"
        },
        {
            "name": "filterAll",
            "baseName": "filter_all",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Endpoint.attributeTypeMap;
    }
}

export class EndpointStatus {
    'online'?: boolean;
    'timeout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "online",
            "baseName": "online",
            "type": "boolean"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EndpointStatus.attributeTypeMap;
    }
}

export class Endpoints {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<Endpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Endpoint>"
        }    ];

    static getAttributeTypeMap() {
        return Endpoints.attributeTypeMap;
    }
}

export class Job {
    'links'?: Links;
    'kind'?: string;
    'id'?: string;
    'status'?: number;
    'created'?: Date;
    'ended'?: Date;
    'at'?: Date;
    'interval'?: number;
    'retry'?: number;
    'retryInterval'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "ended",
            "baseName": "ended",
            "type": "Date"
        },
        {
            "name": "at",
            "baseName": "at",
            "type": "Date"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "retry",
            "baseName": "retry",
            "type": "number"
        },
        {
            "name": "retryInterval",
            "baseName": "retry_interval",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Job.attributeTypeMap;
    }
}

export class Job1 {
    /**
    * Unique name of the access rule
    */
    'name'?: string;
    /**
    * array of http verbs, you may also specify a wildcard ['*']
    */
    'verbs'?: Array<string>;
    /**
    * Array of resources to verify, for example mandator, datatype, object, you may also specify a wildcard ['*']
    */
    'selectors'?: Array<string>;
    /**
    * Resource identifiers to check with selectors, you may also specify a wildcard ['*']
    */
    'resources'?: Array<string>;
    /**
    * Array of role names to apply the rule
    */
    'roles'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<string>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Job1.attributeTypeMap;
    }
}

export class Job2 {
    /**
    * array of http verbs, you may also specify a wildcard ['*']
    */
    'verbs'?: Array<string>;
    /**
    * Array of resources to verify, for example mandator, datatype, object, you may also specify a wildcard ['*']
    */
    'selectors'?: Array<string>;
    /**
    * Resource identifiers to check with selectors, you may also specify a wildcard ['*']
    */
    'resources'?: Array<string>;
    /**
    * Array of role names to apply the rule
    */
    'roles'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<string>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Job2.attributeTypeMap;
    }
}

export class Job3 {
    /**
    * Unique name of the access role
    */
    'name'?: string;
    /**
    * Array of user identifiers to which the role shall be applied
    */
    'users'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Job3.attributeTypeMap;
    }
}

export class Job4 {
    /**
    * Array of user identifiers to which the role shall be applied
    */
    'users'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Job4.attributeTypeMap;
    }
}

export class Job5 {
    /**
    * Type of sync job: 1 (import), 2 (export), (4) import/export
    */
    'type'?: number;
    /**
    * Array of mandators, if not given all mandators are used
    */
    'mandator'?: Array<string>;
    /**
    * Array of datatypes, if not given all datatypes are used
    */
    'datatypes'?: Array<string>;
    /**
    * Array of source endpoints, if not given all mandators are used
    */
    'endpoints'?: Array<string>;
    /**
    * Ignore object error and continue with the next one
    */
    'ignore'?: boolean;
    /**
    * Simulate job
    */
    'simulate'?: boolean;
    /**
    * Specify an interval for this job. If not specified the jobs runs once.
    */
    'interval'?: number;
    /**
    * Specify a retry count for this job. If not specified the job does not repeat if failed before.
    */
    'retry'?: number;
    /**
    * Specify an exact timestamp when the job should get executed. The job will get executed not before this time and not before there is a free slot
    */
    'executeAt'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Array<string>"
        },
        {
            "name": "datatypes",
            "baseName": "datatypes",
            "type": "Array<string>"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        },
        {
            "name": "ignore",
            "baseName": "ignore",
            "type": "boolean"
        },
        {
            "name": "simulate",
            "baseName": "simulate",
            "type": "boolean"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "retry",
            "baseName": "retry",
            "type": "number"
        },
        {
            "name": "executeAt",
            "baseName": "execute_at",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Job5.attributeTypeMap;
    }
}

export class JobError {
    'links'?: Links;
    'kind'?: string;
    'id'?: string;
    'object'?: DataObject;
    'endpoint'?: Endpoint;
    'timestamp'?: Date;
    'message'?: string;
    '_class'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "DataObject"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "Endpoint"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobError.attributeTypeMap;
    }
}

export class JobErrors {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<JobError>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<JobError>"
        }    ];

    static getAttributeTypeMap() {
        return JobErrors.attributeTypeMap;
    }
}

export class Jobs {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<Job>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Job>"
        }    ];

    static getAttributeTypeMap() {
        return Jobs.attributeTypeMap;
    }
}

export class JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JsonPatch.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

export class Links {
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class ListLinks {
    'self'?: Link;
    'prev'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return ListLinks.attributeTypeMap;
    }
}

export class Mandator {
    'links'?: Links;
    'kind'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Mandator.attributeTypeMap;
    }
}

export class Mandators {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<Mandator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Mandator>"
        }    ];

    static getAttributeTypeMap() {
        return Mandators.attributeTypeMap;
    }
}

export class ObjectEndpoint {
    'links'?: ListLinks;
    'kind'?: string;
    'id'?: string;
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ObjectEndpoint.attributeTypeMap;
    }
}

export class ObjectEndpoints {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<ObjectEndpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ObjectEndpoint>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectEndpoints.attributeTypeMap;
    }
}

export class ObjectHistory {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<ObjectHistoryObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ObjectHistoryObject>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectHistory.attributeTypeMap;
    }
}

export class ObjectHistoryObject {
    'links'?: ListLinks;
    'kind'?: string;
    'version'?: number;
    'timestamp'?: Date;
    'object'?: DataObject;
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "DataObject"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ObjectHistoryObject.attributeTypeMap;
    }
}

export class ObjectRelative {
    'links'?: ListLinks;
    'kind'?: string;
    'relativeId'?: string;
    'context'?: any;
    'object'?: DataObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "relativeId",
            "baseName": "relative_id",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "DataObject"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelative.attributeTypeMap;
    }
}

export class ObjectRelatives {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<ObjectRelative>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ObjectRelative>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelatives.attributeTypeMap;
    }
}

export class Schema {
    'links'?: Links;
    'kind'?: string;
    'datatype'?: Datatype;
    'mandator'?: Mandator;
    /**
    * Datatype schema
    */
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "Datatype"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Schema.attributeTypeMap;
    }
}

export class Workflow {
    'links'?: Links;
    'kind'?: string;
    /**
    * Workflow name
    */
    'name'?: string;
    'datatype'?: Datatype;
    'mandator'?: Mandator;
    /**
    * Workflow name
    */
    'endpoint'?: string;
    /**
    * Name of implementation, usually Tubee\\Workflow
    */
    '_class'?: string;
    /**
    * Specifies what type of workflow this is.
    */
    'ensure'?: string;
    /**
    * Workflow condition
    */
    'condition'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "Datatype"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "ensure",
            "baseName": "ensure",
            "type": "string"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Workflow.attributeTypeMap;
    }
}

export class Workflows {
    'links'?: ListLinks;
    'kind'?: string;
    'count'?: number;
    'total'?: number;
    'data'?: Array<Workflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Workflow>"
        }    ];

    static getAttributeTypeMap() {
        return Workflows.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "AccessRole": AccessRole,
    "AccessRoles": AccessRoles,
    "AccessRule": AccessRule,
    "AccessRules": AccessRules,
    "AttributeMap": AttributeMap,
    "Data": Data,
    "Data1": Data1,
    "Data10": Data10,
    "Data11": Data11,
    "Data2": Data2,
    "Data3": Data3,
    "Data4": Data4,
    "Data5": Data5,
    "Data6": Data6,
    "Data7": Data7,
    "Data8": Data8,
    "Data9": Data9,
    "DataObject": DataObject,
    "DataObjects": DataObjects,
    "Datatype": Datatype,
    "Datatypes": Datatypes,
    "Endpoint": Endpoint,
    "EndpointStatus": EndpointStatus,
    "Endpoints": Endpoints,
    "Job": Job,
    "Job1": Job1,
    "Job2": Job2,
    "Job3": Job3,
    "Job4": Job4,
    "Job5": Job5,
    "JobError": JobError,
    "JobErrors": JobErrors,
    "Jobs": Jobs,
    "JsonPatch": JsonPatch,
    "Link": Link,
    "Links": Links,
    "ListLinks": ListLinks,
    "Mandator": Mandator,
    "Mandators": Mandators,
    "ObjectEndpoint": ObjectEndpoint,
    "ObjectEndpoints": ObjectEndpoints,
    "ObjectHistory": ObjectHistory,
    "ObjectHistoryObject": ObjectHistoryObject,
    "ObjectRelative": ObjectRelative,
    "ObjectRelatives": ObjectRelatives,
    "Schema": Schema,
    "Workflow": Workflow,
    "Workflows": Workflows,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccessRolesApiApiKeys {
    api_key,
}

export class AccessRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessRolesApiApiKeys, value: string) {
        (this.authentications as any)[AccessRolesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Create a new access role
     * @param job The access role to create
     */
    public addAccessRole (job?: Job3) : any {
        const localVarPath = this.basePath + '/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Job3")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-role by name
     * @param accessRole Access role name
     */
    public deleteAccessRole (accessRole: string) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(accessRole)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRole' is not null or undefined
        if (accessRole === null || accessRole === undefined) {
            throw new Error('Required parameter accessRole was null or undefined when calling deleteAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access role by name
     * @param accessRole Access role name
     */
    public getAccessRole (accessRole: string) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(accessRole)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRole' is not null or undefined
        if (accessRole === null || accessRole === undefined) {
            throw new Error('Required parameter accessRole was null or undefined when calling getAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access role defines what role is granted access to what resource
     * @summary Get access roles
     * @param query JSON query
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getAccessRoles (query?: string, attributes?: Array<string>, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRoles".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access role
     * @param accessRole Access role name
     * @param job The access role to create
     */
    public replaceAccessRole (accessRole: string, job?: Job4) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(accessRole)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRole' is not null or undefined
        if (accessRole === null || accessRole === undefined) {
            throw new Error('Required parameter accessRole was null or undefined when calling replaceAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Job4")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access role as rfc6902 request
     * @param accessRole Access role name
     * @param job Access role json patch
     */
    public updateAccessRole (accessRole: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(accessRole)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRole' is not null or undefined
        if (accessRole === null || accessRole === undefined) {
            throw new Error('Required parameter accessRole was null or undefined when calling updateAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch access roles
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchAccessRoles (query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchAccessRoles".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccessRulesApiApiKeys {
    api_key,
}

export class AccessRulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessRulesApiApiKeys, value: string) {
        (this.authentications as any)[AccessRulesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Create a new access rule
     * @param job The access rule to create
     */
    public addAccessRule (job?: Job1) : any {
        const localVarPath = this.basePath + '/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Job1")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-rule by name
     * @param accessRule Access rule name
     */
    public deleteAccessRule (accessRule: string) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(accessRule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRule' is not null or undefined
        if (accessRule === null || accessRule === undefined) {
            throw new Error('Required parameter accessRule was null or undefined when calling deleteAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access rule by name
     * @param accessRule Access rule name
     */
    public getAccessRule (accessRule: string) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(accessRule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRule' is not null or undefined
        if (accessRule === null || accessRule === undefined) {
            throw new Error('Required parameter accessRule was null or undefined when calling getAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access rule defines what role is granted access to what resource
     * @summary Get access rules
     * @param query JSON query
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getAccessRules (query?: string, attributes?: Array<string>, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRules".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRules;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access rule
     * @param accessRule Access rule name
     * @param job The access rule to create
     */
    public replaceAccessRule (accessRule: string, job?: Job2) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(accessRule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRule' is not null or undefined
        if (accessRule === null || accessRule === undefined) {
            throw new Error('Required parameter accessRule was null or undefined when calling replaceAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Job2")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access rule as rfc6902 request
     * @param accessRule Access rule name
     * @param job Access rule json patch
     */
    public updateAccessRule (accessRule: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(accessRule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accessRule' is not null or undefined
        if (accessRule === null || accessRule === undefined) {
            throw new Error('Required parameter accessRule was null or undefined when calling updateAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch access rules
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchAccessRules (query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchAccessRules".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataApiApiKeys {
    api_key,
}

export class DataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DataApiApiKeys, value: string) {
        (this.authentications as any)[DataApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Add a new object of a specifc datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data Object
     */
    public addObject (mandator: string, datatype: string, write?: boolean, data?: Data11) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data11")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new object relation to an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param data Object
     */
    public addObjectRelative (mandator: string, datatype: string, object: string, data?: Data9) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling addObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data9")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a specific object
     * @summary Delete object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     */
    public deleteObject (mandator: string, datatype: string, object: string, write?: boolean) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete object relation
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     */
    public deleteObjectRelative (mandator: string, datatype: string, object: string, relative: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling deleteObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get objects from endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint
     * @param query JSON query
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getEndpointObjects (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpointObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the history of all modifications from a specific object
     * @summary Get object history
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query JSON query
     */
    public getHistory (mandator: string, datatype: string, object: string, query?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/history'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getHistory.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getHistory.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getHistory.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getHistory".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectHistory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectHistory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an object of a specific datatype
     * @summary Get specific object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param attributes Filter attributes
     */
    public getObject (mandator: string, datatype: string, object: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObject.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get object from all endpoints the object is related to
     * @summary Get object from endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param endpoint Endpoint nmae
     */
    public getObjectEndpoint (mandator: string, datatype: string, object: string, endpoint: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectEndpoint.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getObjectEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectEndpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectEndpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get object from all endpoints the object is related to
     * @summary Get object from endpoints
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query JSON query
     */
    public getObjectEndpoints (mandator: string, datatype: string, object: string, query?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectEndpoints.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectEndpoints.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectEndpoints".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectEndpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectEndpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relative object of an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     */
    public getObjectRelative (mandator: string, datatype: string, object: string, relative: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling getObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all objects the object is related to
     * @summary Get relative objects of an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query JSON query
     */
    public getObjectRelatives (mandator: string, datatype: string, object: string, query?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectRelatives.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectRelatives.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelatives.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectRelatives".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelatives;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelatives");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A object is a data object from a specifc datatype
     * @summary Get objects of a specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query JSON query
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getObjects (mandator: string, datatype: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace all data attributes of an object (Or create one if not exists)
     * @summary Replace or create object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data Object
     */
    public replaceObject (mandator: string, datatype: string, object: string, write?: boolean, data?: Data8) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling replaceObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data8")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of an object
     * @summary Patch object as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data Object
     */
    public updateObject (mandator: string, datatype: string, object: string, write?: boolean, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update object relation
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     * @param data Object
     */
    public updateObjectRelative (mandator: string, datatype: string, object: string, relative: string, data?: Data10) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling updateObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data10")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch datatypes in realtime
     * @summary Watch datatypes
     * @param mandator Mandator name
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchDatatypes (mandator: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchDatatypes.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchDatatypes".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch endpoints
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchEndpoints (mandator: string, datatype: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchEndpoints.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchEndpoints".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch mandators in realtime
     * @summary Watch mandators
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchMandators (query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchMandators".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch object relatives
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchObjectRelatives (mandator: string, datatype: string, object: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchObjectRelatives.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchObjectRelatives.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling watchObjectRelatives.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchObjectRelatives".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch objects
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchObjects (mandator: string, datatype: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch workflows
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public watchWorkflows (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchWorkflows.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling watchWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchWorkflows".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DatatypesApiApiKeys {
    api_key,
}

export class DatatypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DatatypesApiApiKeys, value: string) {
        (this.authentications as any)[DatatypesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Add datatype
     * @param mandator Mandator name
     * @param data Datatype
     */
    public addDatatype (mandator: string, data?: Data2) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data2")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     */
    public deleteDatatype (mandator: string, datatype: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A datatype is collection of dataobjects of a specific type
     * @summary Get specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param attributes Filter attributes
     */
    public getDatatype (mandator: string, datatype: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getDatatype.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A datatype is collection of data objects of a specific type
     * @summary Get datatypes
     * @param mandator Mandator name
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public getDatatypes (mandator: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getDatatypes.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getDatatypes".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatypes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatypes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data Datatype
     */
    public replaceDatatype (mandator: string, datatype: string, data?: Data3) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data3")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a datatype
     * @summary Patch datatype as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data Datatype
     */
    public updateDatatype (mandator: string, datatype: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EndpointsApiApiKeys {
    api_key,
}

export class EndpointsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EndpointsApiApiKeys, value: string) {
        (this.authentications as any)[EndpointsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Add Endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data Endpoint
     */
    public addEndpoint (mandator: string, datatype: string, data?: Data4) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data4")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     */
    public deleteEndpoint (mandator: string, datatype: string, endpoint: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get specific endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param attributes Filter attributes
     */
    public getEndpoint (mandator: string, datatype: string, endpoint: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpoint.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get endpoints
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public getEndpoints (mandator: string, datatype: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpoints.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpoints".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace endppoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data Datatype
     */
    public replaceEndpoint (mandator: string, datatype: string, endpoint: string, data?: Data5) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data5")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a endpoint
     * @summary Patch datatype as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data Datatype
     */
    public updateEndpoint (mandator: string, datatype: string, endpoint: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum JobsApiApiKeys {
    api_key,
}

export class JobsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: JobsApiApiKeys, value: string) {
        (this.authentications as any)[JobsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Create new job
     * @param job The job to create
     */
    public addJob (job?: Job5) : any {
        const localVarPath = this.basePath + '/jobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Job5")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete job by id
     * @param job Job ID
     */
    public deleteJob (job: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling deleteJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get job by id
     * @param job Job ID
     */
    public getJob (job: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single job error
     * @param job Job ID
     * @param error Error id
     */
    public getJobError (job: string, error: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}/errors/{error}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)))
            .replace('{' + 'error' + '}', encodeURIComponent(String(error)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobError.');
        }

        // verify required parameter 'error' is not null or undefined
        if (error === null || error === undefined) {
            throw new Error('Required parameter error was null or undefined when calling getJobError.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobError".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: JobError;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "JobError");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all errors of a job
     * @param job Job ID
     * @param attributes Filter attributes
     * @param query Complex query to get a specific set of objects (A mongodb compatible query can be applied)
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getJobErrors (job: string, attributes?: Array<string>, query?: string, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/jobs/{job}/errors'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobErrors.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobErrors".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: JobErrors;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "JobErrors");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A job is an asynchronous server process
     * @summary Get list of active queued jobs
     * @param query JSON query
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0
     * @param limit Objects limit, per default 20 objects will get returned
     */
    public getJobs (query?: string, attributes?: Array<string>, offset?: number, limit?: number) : any {
        const localVarPath = this.basePath + '/jobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Jobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Jobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Monitor  job erros as live stream (Long running http request, needs to be resend after timeout)
     * @param job Job ID
     * @param attributes Filter attributes
     * @param query Complex query to get a specific set of objects (A mongodb compatible query can be applied)
     */
    public watchJobErrors (job: string, attributes?: Array<string>, query?: string) : any {
        const localVarPath = this.basePath + '/watch/jobs/{job}/errors'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling watchJobErrors.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchJobErrors".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: JobErrors;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "JobErrors");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MandatorsApiApiKeys {
    api_key,
}

export class MandatorsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MandatorsApiApiKeys, value: string) {
        (this.authentications as any)[MandatorsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Add mandator
     * @param data Mandator
     */
    public addMandator (data?: Data) : any {
        const localVarPath = this.basePath + '/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific mandator
     * @param mandator Mandator name
     */
    public deleteMandator (mandator: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteMandator.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A mandator is a logical group of datatypes
     * @summary Get specific mandator
     * @param mandator Mandator name
     * @param attributes Filter attributes
     */
    public getMandator (mandator: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getMandator.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A mandator is a logical group of datatypes
     * @summary Get mandators
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public getMandators (query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getMandators".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandators;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandators");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a mandator
     * @summary Patch mandator as rfc6902 request
     * @param mandator Mandator name
     * @param data Mandator
     */
    public mandatorsMandatorPatch (mandator: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling mandatorsMandatorPatch.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("mandatorsMandatorPatch".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace mandator
     * @param mandator Mandator name
     * @param data Mandator
     */
    public replaceMandator (mandator: string, data?: Data1) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceMandator.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data1")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WorkflowsApiApiKeys {
    api_key,
}

export class WorkflowsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'api_key'),
        'petstore_auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WorkflowsApiApiKeys, value: string) {
        (this.authentications as any)[WorkflowsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.petstore_auth.accessToken = token;
    }
    /**
     * 
     * @summary Add worfklow to endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data Workflow
     */
    public addWorkflow (mandator: string, datatype: string, endpoint: string, data?: Data6) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling addWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data6")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific workflow from
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     */
    public deleteWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling deleteWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a datatype and with what attribute map
     * @summary Get specifc endpoint workflow
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param attributes Filter attributes
     */
    public getWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling getWorkflow.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a datatype and with what attribute map
     * @summary Get endpoint workflows
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param query JSON query
     * @param attributes Filter attributes
     */
    public getWorkflows (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getWorkflows".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflows;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflows");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace workflow
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data Workflow
     */
    public replaceWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, data?: Data7) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling replaceWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Data7")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a workflow
     * @summary Patch workflow as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data Workflow
     */
    public updateWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling updateWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.petstore_auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
