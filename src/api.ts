/**
 * Tubee API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: opensource@gyselroth.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
export {localVarRequest};
import http = require('http');
import Promise = require('bluebird');

export const specPath = __dirname+'/../swagger.yml';

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessRoleData {
    /**
    * A list of user identifiers which the access role should match. It is also possible to specify a wildcard to match all identifiers.
    */
    'selectors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRoleData.attributeTypeMap;
    }
}

export class AccessRuleData {
    /**
    * A list of access-role names to match the given rule.
    */
    'roles'?: Array<string>;
    /**
    * List of allowed HTTP rfc7231 verbs, you may also specify a wildcard to match all verbs.
    */
    'verbs'?: Array<AccessRuleData.VerbsEnum>;
    /**
    * A list of selectors to match resources, for example namespace, collection, endpoint, ...
    */
    'selectors'?: Array<string>;
    /**
    * Values according to your selector list required to match a request.
    */
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        },
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<AccessRuleData.VerbsEnum>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRuleData.attributeTypeMap;
    }
}

export namespace AccessRuleData {
    export enum VerbsEnum {
        Star = <any> '*',
        GET = <any> 'GET',
        POST = <any> 'POST',
        PUT = <any> 'PUT',
        PATCH = <any> 'PATCH',
        DELETE = <any> 'DELETE',
        HEAD = <any> 'HEAD'
    }
}
export class AttributeMap {
    /**
    * Attribute map
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AttributeMap.attributeTypeMap;
    }
}

export class BalloonEndpointData {
    'resource': BalloonEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "BalloonEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return BalloonEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class BalloonEndpointDataResource {
    /**
    * Base uri to resources (Like https://rest.api/v2/users).
    */
    'base_uri': string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    /**
    * Authentication adapter, either of none, http basic authentication or oauth2 using client_credentials flow.
    */
    'auth'?: BalloonEndpointDataResource.AuthEnum;
    'basic'?: OdataRestEndpointDataResourceBasic;
    'oauth2'?: BalloonEndpointDataResourceOauth2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "BalloonEndpointDataResource.AuthEnum"
        },
        {
            "name": "basic",
            "baseName": "basic",
            "type": "OdataRestEndpointDataResourceBasic"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "BalloonEndpointDataResourceOauth2"
        }    ];

    static getAttributeTypeMap() {
        return BalloonEndpointDataResource.attributeTypeMap;
    }
}

export namespace BalloonEndpointDataResource {
    export enum AuthEnum {
        Basic = <any> 'basic',
        Oauth2 = <any> 'oauth2'
    }
}
/**
* Oauth2 client credentials flow. auth must be set to oauth2 if this adapter should be used.
*/
export class BalloonEndpointDataResourceOauth2 {
    /**
    * URI to token endpoint.
    */
    'token_uri'?: string;
    /**
    * OAuth2 client_id.
    */
    'client_id'?: string;
    /**
    * OAuth2 client_secret. Note the client_secret gets encrypted on the server an can't be retrieved after it.
    */
    'client_secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token_uri",
            "baseName": "token_uri",
            "type": "string"
        },
        {
            "name": "client_id",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "client_secret",
            "baseName": "client_secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonEndpointDataResourceOauth2.attributeTypeMap;
    }
}

export class CollectionData {
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CollectionData.attributeTypeMap;
    }
}

export class CsvEndpointData {
    'storage'?: Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;
    'resource'?: CsvEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CsvEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CsvEndpointData.attributeTypeMap;
    }
}

/**
* CSV parse options.
*/
export class CsvEndpointDataResource {
    /**
    * Field delimiter.
    */
    'delimiter'?: string;
    /**
    * Field enclosure.
    */
    'enclosure'?: string;
    /**
    * Escape character.
    */
    'escape'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "delimiter",
            "baseName": "delimiter",
            "type": "string"
        },
        {
            "name": "enclosure",
            "baseName": "enclosure",
            "type": "string"
        },
        {
            "name": "escape",
            "baseName": "escape",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CsvEndpointDataResource.attributeTypeMap;
    }
}

export class EndpointData {
    /**
    * Specify the type of the endpoint.
    */
    'type'?: EndpointData.TypeEnum;
    'options'?: EndpointDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "EndpointData.TypeEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "EndpointDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return EndpointData.attributeTypeMap;
    }
}

export namespace EndpointData {
    export enum TypeEnum {
        Browse = <any> 'browse',
        Source = <any> 'source',
        Destination = <any> 'destination',
        Bidirectional = <any> 'bidirectional'
    }
}
export class EndpointDataOptions {
    /**
    * Endpoint resource identifier.
    */
    'identifier'?: string;
    /**
    * A list of attributes which gets used to uniquely identify an object on the endpoint.
    */
    'import'?: Array<string>;
    /**
    * If true and the endpoint is of type source, the endpoint gets flushed before export. If the type is destination, the endpoints collection gets flushed before import. Pay attention with flush as it may result in data loss!
    */
    'flush'?: boolean;
    /**
    * Specify an endpoint filter which gets used to filter for a single object.
    */
    'filter_one'?: string;
    /**
    * Specify a filter which always gets applied to the endpoint if objects are retrieved.
    */
    'filter_all'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "import",
            "baseName": "import",
            "type": "Array<string>"
        },
        {
            "name": "flush",
            "baseName": "flush",
            "type": "boolean"
        },
        {
            "name": "filter_one",
            "baseName": "filter_one",
            "type": "string"
        },
        {
            "name": "filter_all",
            "baseName": "filter_all",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EndpointDataOptions.attributeTypeMap;
    }
}

export class JobData {
    'notification'?: JobDataNotification;
    /**
    * A list of collections (name) the job should match. You may use a wildcard to specify all collections. Each element may contain either a single collection name or a list of collections. A list will be processed in parallel while single collections get synchronized syncronely
    */
    'collections'?: Array<string>;
    /**
    * A list of endoints (name) the job should match. You may use a wildcard to specify all endpoints. Each element may contain either a single endpoint name or a list of endpoints. A list will be processed in parallel while single endpoints get synchronized syncronely.
    */
    'endpoints'?: Array<string>;
    /**
    * Data object filter.
    */
    'filter'?: any;
    /**
    * If enabled the server does ignores any sync errors and continue with the process.
    */
    'ignore'?: boolean;
    /**
    * You may change the log level which gets applied during a sync job. Note that a log level too verbose has a big impact on the sync performance.
    */
    'log_level'?: JobData.LogLevelEnum;
    'options'?: JobDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notification",
            "baseName": "notification",
            "type": "JobDataNotification"
        },
        {
            "name": "collections",
            "baseName": "collections",
            "type": "Array<string>"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "ignore",
            "baseName": "ignore",
            "type": "boolean"
        },
        {
            "name": "log_level",
            "baseName": "log_level",
            "type": "JobData.LogLevelEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "JobDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return JobData.attributeTypeMap;
    }
}

export namespace JobData {
    export enum LogLevelEnum {
        Emerg = <any> 'emerg',
        Error = <any> 'error',
        Warn = <any> 'warn',
        Info = <any> 'info',
        Notice = <any> 'notice',
        Debug = <any> 'debug'
    }
}
export class JobDataNotification {
    /**
    * You may enable mail notification for a given job.
    */
    'enabled'?: boolean;
    /**
    * A list of mail adresses which the notification should be sent to. This option has no affect if notification is disabled.
    */
    'receiver'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "receiver",
            "baseName": "receiver",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return JobDataNotification.attributeTypeMap;
    }
}

/**
* Holds options about when a job should start and with what interval.
*/
export class JobDataOptions {
    /**
    * Holds a unix timestamp at what time the job should be executed.
    */
    'at'?: string;
    /**
    * The number of secconds after the job should be executed again. The default is only run once.
    */
    'interval'?: number;
    /**
    * The number of times a failed job should be restarted. The default is never.
    */
    'retry'?: number;
    /**
    * The number of secconds beween failed job retries. The default is 300 (5min).
    */
    'retry_interval'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "at",
            "baseName": "at",
            "type": "string"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "retry",
            "baseName": "retry",
            "type": "number"
        },
        {
            "name": "retry_interval",
            "baseName": "retry_interval",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDataOptions.attributeTypeMap;
    }
}

export class JsonEndpointData {
    'storage'?: Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JsonEndpointData.attributeTypeMap;
    }
}

/**
* A JSON Patch according rfc6902.
*/
export class JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JsonPatch.attributeTypeMap;
    }
}

export class LdapEndpointData {
    'resource'?: LdapEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "LdapEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return LdapEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class LdapEndpointDataResource {
    /**
    * A full LDAP URI of the form ldap://hostname:port or ldaps://hostname:port for SSL encryption.
    */
    'uri'?: string;
    /**
    * Bind DN if required.
    */
    'binddn'?: string;
    /**
    * Bind password if required.
    */
    'bindpw'?: string;
    /**
    * Specifies the base dn (Like dc=example,dc=net).
    */
    'basedn'?: string;
    /**
    * Set to true if TLS shall be used.
    */
    'tls'?: boolean;
    /**
    * More ldap specific settings (http://php.net/manual/en/function.ldap-set-option.php).
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "binddn",
            "baseName": "binddn",
            "type": "string"
        },
        {
            "name": "bindpw",
            "baseName": "bindpw",
            "type": "string"
        },
        {
            "name": "basedn",
            "baseName": "basedn",
            "type": "string"
        },
        {
            "name": "tls",
            "baseName": "tls",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LdapEndpointDataResource.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

/**
* Contains resource links (URL) to other resources.
*/
export class Links {
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class List {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return List.attributeTypeMap;
    }
}

export class ListLinks {
    'self'?: Link;
    'prev'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return ListLinks.attributeTypeMap;
    }
}

export class LogData {
    'level'?: number;
    'level_name'?: string;
    /**
    * The log message.
    */
    'message'?: string;
    /**
    * The server component which logged the message.
    */
    'category'?: string;
    /**
    * Holds an exception object if the log message holds an exception reference.
    */
    'exception'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "level_name",
            "baseName": "level_name",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "exception",
            "baseName": "exception",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LogData.attributeTypeMap;
    }
}

export class MongodbEndpointData {
    /**
    * The name of the MongoDB collection where the data is located at.
    */
    'collection'?: string;
    'resource'?: MongodbEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "collection",
            "baseName": "collection",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "MongodbEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return MongodbEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class MongodbEndpointDataResource {
    /**
    * MongoDB connection uri
    */
    'uri'?: string;
    /**
    * Advanced URI options
    */
    'uri_options'?: any;
    /**
    * Advanced Driver options
    */
    'driver_options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "uri_options",
            "baseName": "uri_options",
            "type": "any"
        },
        {
            "name": "driver_options",
            "baseName": "driver_options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return MongodbEndpointDataResource.attributeTypeMap;
    }
}

export class MysqlEndpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: MysqlEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "MysqlEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return MysqlEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class MysqlEndpointDataResource {
    /**
    * MySQL Server (Or compatible MySQL fork like MariaDB).
    */
    'host'?: string;
    /**
    * Username.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'passwd'?: string;
    /**
    * Specifies the port number to attempt to connect to the MySQL server.
    */
    'port'?: number;
    /**
    * Specifies the socket or named pipe that should be used.
    */
    'socket'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "socket",
            "baseName": "socket",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MysqlEndpointDataResource.attributeTypeMap;
    }
}

export class ObjectRelationData {
    /**
    * Optional context context data which describes the relationship.
    */
    'context'?: any;
    /**
    * Holds the relationship between two objects. You may create cross collection and cross namespace object relationships.
    */
    'relation'?: Array<ObjectRelationDataRelation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        },
        {
            "name": "relation",
            "baseName": "relation",
            "type": "Array<ObjectRelationDataRelation>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelationData.attributeTypeMap;
    }
}

export class ObjectRelationDataRelation {
    /**
    * Name of the objects namespace
    */
    'namespace'?: string;
    /**
    * Name of the objects collection
    */
    'collection'?: string;
    /**
    * Name of the object
    */
    'object'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelationDataRelation.attributeTypeMap;
    }
}

export class OdataRestEndpointData {
    'resource'?: OdataRestEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "OdataRestEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return OdataRestEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class OdataRestEndpointDataResource {
    /**
    * Base uri to resources (Like https://rest.api/v1/resources).
    */
    'base_uri'?: string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    /**
    * Authentication adapter, either of none, http basic authentication or oauth2 using client_credentials flow.
    */
    'auth'?: OdataRestEndpointDataResource.AuthEnum;
    'basic'?: OdataRestEndpointDataResourceBasic;
    'oauth2'?: OdataRestEndpointDataResourceOauth2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "OdataRestEndpointDataResource.AuthEnum"
        },
        {
            "name": "basic",
            "baseName": "basic",
            "type": "OdataRestEndpointDataResourceBasic"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "OdataRestEndpointDataResourceOauth2"
        }    ];

    static getAttributeTypeMap() {
        return OdataRestEndpointDataResource.attributeTypeMap;
    }
}

export namespace OdataRestEndpointDataResource {
    export enum AuthEnum {
        Basic = <any> 'basic',
        Oauth2 = <any> 'oauth2'
    }
}
/**
* HTTP Basic authentication. auth must be set to basic if this adapter should be used.
*/
export class OdataRestEndpointDataResourceBasic {
    /**
    * Basic authentication username.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OdataRestEndpointDataResourceBasic.attributeTypeMap;
    }
}

/**
* Oauth2 client credentials flow. auth must be set to oauth2 if this adapter should be used.
*/
export class OdataRestEndpointDataResourceOauth2 {
    /**
    * URI to token endpoint.
    */
    'token_endpoint'?: string;
    /**
    * OAuth2 client_id.
    */
    'client_id'?: string;
    /**
    * OAuth2 client_secret. Note the client_secret gets encrypted on the server an can't be retrieved after it.
    */
    'client_secret'?: string;
    /**
    * OAuth2 scopes
    */
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token_endpoint",
            "baseName": "token_endpoint",
            "type": "string"
        },
        {
            "name": "client_id",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "client_secret",
            "baseName": "client_secret",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OdataRestEndpointDataResourceOauth2.attributeTypeMap;
    }
}

export class PdoEndpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: PdoEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "PdoEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return PdoEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class PdoEndpointDataResource {
    /**
    * Data source name (DSN).
    */
    'dsn'?: string;
    /**
    * Username if required.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'passwd'?: string;
    /**
    * Driver specific connection options.
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dsn",
            "baseName": "dsn",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return PdoEndpointDataResource.attributeTypeMap;
    }
}

/**
* Holds the status of this resource. Note that status is immutable.
*/
export class ProcessStatus {
    /**
    * The result code of the process.
    */
    'code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessStatus.attributeTypeMap;
    }
}

export class Resource {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        }    ];

    static getAttributeTypeMap() {
        return Resource.attributeTypeMap;
    }
}

export class SecretMount {
    /**
    * The name of the secret from which the key's value should be injected.
    */
    'secret'?: string;
    /**
    * The name of the key which should be taken from a secret (You may use a recursive path by delimiting keys with '.', for example: password).
    */
    'key'?: string;
    /**
    * The resource path where the secret value should be injected (You may use a recursive path by delimiting keys with '.', for example: data.resource.password).
    */
    'to'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SecretMount.attributeTypeMap;
    }
}

/**
* The storage defines where data can be fetched.
*/
export class Storage {
    /**
    * The kind of storage where data shall be fetched.
    */
    'kind'?: Storage.KindEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "Storage.KindEnum"
        }    ];

    static getAttributeTypeMap() {
        return Storage.attributeTypeMap;
    }
}

export namespace Storage {
    export enum KindEnum {
        Stream = <any> 'Stream',
        LocalFilesystem = <any> 'LocalFilesystem',
        Smb = <any> 'Smb',
        Balloon = <any> 'Balloon'
    }
}
export class UcsEndpointData {
    'resource'?: UcsEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "UcsEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return UcsEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class UcsEndpointDataResource {
    /**
    * Base uri to univention server (usually including /univention) (Like https://master/univention).
    */
    'base_uri'?: string;
    /**
    * Object type flavor (For example users/user or groups/group).
    */
    'flavor'?: string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    'auth'?: OdataRestEndpointDataResourceBasic;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "flavor",
            "baseName": "flavor",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "OdataRestEndpointDataResourceBasic"
        }    ];

    static getAttributeTypeMap() {
        return UcsEndpointDataResource.attributeTypeMap;
    }
}

/**
* The user information.
*/
export class UserData {
    /**
    * The users password. Gets hashed on the server and can not be retrieved after.
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserData.attributeTypeMap;
    }
}

export class WorkflowData {
    /**
    * The priority defines in what order multiple workflows get executed. 0 (Default) is the highest priority.
    */
    'priority'?: number;
    'ensure'?: WorkflowData.EnsureEnum;
    /**
    * Holds a scripted condition if a given workflow gets matched and executed.
    */
    'condition'?: string;
    /**
    * Map attributes from the endpoint to the collection schema (if the endpoint is of type source) or map attributes from the collection to the endpoint if the endpoint is of type destination.
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "ensure",
            "baseName": "ensure",
            "type": "WorkflowData.EnsureEnum"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return WorkflowData.attributeTypeMap;
    }
}

export namespace WorkflowData {
    export enum EnsureEnum {
        Last = <any> 'last',
        Exists = <any> 'exists',
        Absent = <any> 'absent',
        Merge = <any> 'merge'
    }
}
export class XmlEndpointData {
    'storage'?: Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;
    'resource'?: XmlEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "XmlEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return XmlEndpointData.attributeTypeMap;
    }
}

/**
* CSV parse options.
*/
export class XmlEndpointDataResource {
    /**
    * The name of the root element.
    */
    'root_name'?: string;
    /**
    * The name of the sub node of the root element. For example: <root><row><a>0</a></row><a>1</a><row></row</root>
    */
    'node_name'?: string;
    /**
    * Prettify xml output, note this is only useful if the XmlEndpoint is a destination endpoint.
    */
    'pretty'?: boolean;
    /**
    * Preserve whitespace, note this is only useful if the XmlEndpoint is a destination endpoint.
    */
    'preserve_whitespace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "root_name",
            "baseName": "root_name",
            "type": "string"
        },
        {
            "name": "node_name",
            "baseName": "node_name",
            "type": "string"
        },
        {
            "name": "pretty",
            "baseName": "pretty",
            "type": "boolean"
        },
        {
            "name": "preserve_whitespace",
            "baseName": "preserve_whitespace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return XmlEndpointDataResource.attributeTypeMap;
    }
}

/**
* An access role is defined list which matches authenticated user identifiers.
*/
export class AccessRole {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always AccessRole.
    */
    'kind'?: string;
    'data'?: AccessRoleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AccessRoleData"
        }    ];

    static getAttributeTypeMap() {
        return AccessRole.attributeTypeMap;
    }
}

/**
* A list of access roles.
*/
export class AccessRoles {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<AccessRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRole>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRoles.attributeTypeMap;
    }
}

/**
* An access rule allows to specify what access roles can access which resources.
*/
export class AccessRule {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always AccessRule.
    */
    'kind'?: string;
    'data'?: AccessRuleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AccessRuleData"
        }    ];

    static getAttributeTypeMap() {
        return AccessRule.attributeTypeMap;
    }
}

/**
* A list of access rules.
*/
export class AccessRules {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<AccessRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRule>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRules.attributeTypeMap;
    }
}

/**
* A collection is a collection of data objects, meaning a collection of similar objects.
*/
export class Collection {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Collection.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: CollectionData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CollectionData"
        }    ];

    static getAttributeTypeMap() {
        return Collection.attributeTypeMap;
    }
}

/**
* A list of collections.
*/
export class Collections {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Collections>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Collections>"
        }    ];

    static getAttributeTypeMap() {
        return Collections.attributeTypeMap;
    }
}

/**
* A data object represents a single object in a collection (data collection).
*/
export class DataObject {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always DataObject.
    */
    'kind'?: string;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DataObject.attributeTypeMap;
    }
}

/**
* List of data objects.
*/
export class DataObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<DataObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<DataObject>"
        }    ];

    static getAttributeTypeMap() {
        return DataObjects.attributeTypeMap;
    }
}

/**
* An endpoint represents an external resource to browse (proxy), import or export. This may be a database, a file, a http service, ...
*/
export class Endpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint.
    */
    'kind'?: Endpoint.KindEnum;
    'data'?: EndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "Endpoint.KindEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "EndpointData"
        }    ];

    static getAttributeTypeMap() {
        return Endpoint.attributeTypeMap;
    }
}

export namespace Endpoint {
    export enum KindEnum {
        PdoEndpoint = <any> 'PdoEndpoint',
        MysqlEndpoint = <any> 'MysqlEndpoint',
        XmlEndpoint = <any> 'XmlEndpoint',
        CsvEndpoint = <any> 'CsvEndpoint',
        ImageEndpoint = <any> 'ImageEndpoint',
        JsonEndpoint = <any> 'JsonEndpoint',
        MongodbEndpoint = <any> 'MongodbEndpoint',
        MoodleEndpoint = <any> 'MoodleEndpoint',
        BalloonEndpoint = <any> 'BalloonEndpoint',
        OdataRestEndpoint = <any> 'OdataRestEndpoint',
        UcsEndpoint = <any> 'UcsEndpoint'
    }
}
/**
* An endpoint object is the actual object on an endpoint itself.
*/
export class EndpointObject {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return EndpointObject.attributeTypeMap;
    }
}

/**
* A list of endpoint objects.
*/
export class EndpointObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always EndpointObject.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<EndpointObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<EndpointObject>"
        }    ];

    static getAttributeTypeMap() {
        return EndpointObjects.attributeTypeMap;
    }
}

/**
* A list of endpoints.
*/
export class Endpoints {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Endpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Endpoint>"
        }    ];

    static getAttributeTypeMap() {
        return Endpoints.attributeTypeMap;
    }
}

/**
* A job is a synchronization job which declares when and what collections should be synchronized.
*/
export class Job {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Job.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: JobData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "JobData"
        }    ];

    static getAttributeTypeMap() {
        return Job.attributeTypeMap;
    }
}

/**
* A list of jobs.
*/
export class Jobs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Job>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Job>"
        }    ];

    static getAttributeTypeMap() {
        return Jobs.attributeTypeMap;
    }
}

/**
* A log messagage from a process.
*/
export class Log {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Log.
    */
    'kind'?: string;
    'data'?: LogData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "LogData"
        }    ];

    static getAttributeTypeMap() {
        return Log.attributeTypeMap;
    }
}

/**
* A list of logs.
*/
export class Logs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Log>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Log>"
        }    ];

    static getAttributeTypeMap() {
        return Logs.attributeTypeMap;
    }
}

/**
* A namespace is a namespace to separate resources.
*/
export class Namespace {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Namespace.
    */
    'kind'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Namespace.attributeTypeMap;
    }
}

/**
* A list of namespaces.
*/
export class Namespaces {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Namespace>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Namespace>"
        }    ];

    static getAttributeTypeMap() {
        return Namespaces.attributeTypeMap;
    }
}

/**
* An object relation represents a releationship between two data objects. A relationship may apply to objects of different collections and/or namespaces.
*/
export class ObjectRelation {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always DataObjectRelation.
    */
    'kind'?: string;
    'data'?: ObjectRelationData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "ObjectRelationData"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelation.attributeTypeMap;
    }
}

/**
* A list of relations.
*/
export class ObjectRelations {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<ObjectRelation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ObjectRelation>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelations.attributeTypeMap;
    }
}

/**
* A list of processes.
*/
export class Processes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Process>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Process>"
        }    ];

    static getAttributeTypeMap() {
        return Processes.attributeTypeMap;
    }
}

/**
* A secret is sensitive information which can be injected into another resource. A secret gets specially encrypted on the server and is always base64 encoded.
*/
export class Secret {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Secret.
    */
    'kind'?: string;
    /**
    * The secrets data. You may specify multiple keys. Important: You need to base64 encode the values!
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Secret.attributeTypeMap;
    }
}

/**
* A list of secrets.
*/
export class Secrets {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Secret>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Secret>"
        }    ];

    static getAttributeTypeMap() {
        return Secrets.attributeTypeMap;
    }
}

/**
* A local tubee user.
*/
export class User {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always User.
    */
    'kind'?: string;
    'data'?: UserData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "UserData"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

/**
* A list of users.
*/
export class Users {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<User>"
        }    ];

    static getAttributeTypeMap() {
        return Users.attributeTypeMap;
    }
}

/**
* A workflow gets used if an endpoint gets imported or exported. A workflow defines if and what object and also if and what attributes of an object should be written to or from an endpoint.
*/
export class Workflow {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Workflow.
    */
    'kind'?: string;
    'data'?: WorkflowData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "WorkflowData"
        }    ];

    static getAttributeTypeMap() {
        return Workflow.attributeTypeMap;
    }
}

/**
* A list of workflows.
*/
export class Workflows {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Workflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Workflow>"
        }    ];

    static getAttributeTypeMap() {
        return Workflows.attributeTypeMap;
    }
}

/**
* Balloon cloud server endpoint
*/
export class BalloonEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always BalloonEndpoint.
    */
    'kind': string;
    'data': BalloonEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "BalloonEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return BalloonEndpoint.attributeTypeMap;
    }
}

/**
* CSV data format endpoint
*/
export class CsvEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always CsvEndpoint.
    */
    'kind'?: string;
    'data'?: CsvEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CsvEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CsvEndpoint.attributeTypeMap;
    }
}

/**
* JSON data format endpoint
*/
export class JsonEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always JsonEndpoint.
    */
    'kind'?: string;
    'data'?: JsonEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "JsonEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return JsonEndpoint.attributeTypeMap;
    }
}

/**
* LDAP (OpenLDAP, Microsoft AD and other LDAP compatible Server) endpoint
*/
export class LdapEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always LdapEndpoint.
    */
    'kind'?: string;
    'data'?: LdapEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "LdapEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return LdapEndpoint.attributeTypeMap;
    }
}

/**
* MongoDB endpoint
*/
export class MongodbEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always MongodbEndpoint.
    */
    'kind'?: string;
    'data'?: MongodbEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "MongodbEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return MongodbEndpoint.attributeTypeMap;
    }
}

/**
* MySQL/MariaDB (and other MySQL forks) endpoint
*/
export class MysqlEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always MysqlEndpoint.
    */
    'kind'?: string;
    'data'?: MysqlEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "MysqlEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return MysqlEndpoint.attributeTypeMap;
    }
}

/**
* OData REST API endpoint (Compatible with Microsoft graph (Office365 and more) and other OData compatible api's)
*/
export class OdataRestEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always OdataRestEndpoint.
    */
    'kind'?: string;
    'data'?: OdataRestEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "OdataRestEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return OdataRestEndpoint.attributeTypeMap;
    }
}

/**
* Pdo endpoint
*/
export class PdoEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always PdoEndpoint.
    */
    'kind'?: string;
    'data'?: PdoEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "PdoEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return PdoEndpoint.attributeTypeMap;
    }
}

/**
* A process is a sub resource of a job. Each process represents one job execution.
*/
export class Process {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The resource type, always Process.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: JobData;
    'status'?: ProcessStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "JobData"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ProcessStatus"
        }    ];

    static getAttributeTypeMap() {
        return Process.attributeTypeMap;
    }
}

/**
* UCS endpoint (Univention Corporate Server, https://www.univention.com/products/ucs)
*/
export class UcsEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always UcsEndpoint.
    */
    'kind'?: string;
    'data'?: UcsEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "UcsEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return UcsEndpoint.attributeTypeMap;
    }
}

/**
* XML data format endpoint
*/
export class XmlEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<SecretMount>;
    /**
    * The type of endpoint. Always XmlEndpoint.
    */
    'kind'?: string;
    'data'?: XmlEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "XmlEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return XmlEndpoint.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AccessRuleData.VerbsEnum": AccessRuleData.VerbsEnum,
        "BalloonEndpointDataResource.AuthEnum": BalloonEndpointDataResource.AuthEnum,
        "EndpointData.TypeEnum": EndpointData.TypeEnum,
        "JobData.LogLevelEnum": JobData.LogLevelEnum,
        "OdataRestEndpointDataResource.AuthEnum": OdataRestEndpointDataResource.AuthEnum,
        "Storage.KindEnum": Storage.KindEnum,
        "WorkflowData.EnsureEnum": WorkflowData.EnsureEnum,
        "Endpoint.KindEnum": Endpoint.KindEnum,
}

let typeMap: {[index: string]: any} = {
    "AccessRoleData": AccessRoleData,
    "AccessRuleData": AccessRuleData,
    "AttributeMap": AttributeMap,
    "BalloonEndpointData": BalloonEndpointData,
    "BalloonEndpointDataResource": BalloonEndpointDataResource,
    "BalloonEndpointDataResourceOauth2": BalloonEndpointDataResourceOauth2,
    "CollectionData": CollectionData,
    "CsvEndpointData": CsvEndpointData,
    "CsvEndpointDataResource": CsvEndpointDataResource,
    "EndpointData": EndpointData,
    "EndpointDataOptions": EndpointDataOptions,
    "JobData": JobData,
    "JobDataNotification": JobDataNotification,
    "JobDataOptions": JobDataOptions,
    "JsonEndpointData": JsonEndpointData,
    "JsonPatch": JsonPatch,
    "LdapEndpointData": LdapEndpointData,
    "LdapEndpointDataResource": LdapEndpointDataResource,
    "Link": Link,
    "Links": Links,
    "List": List,
    "ListLinks": ListLinks,
    "LogData": LogData,
    "MongodbEndpointData": MongodbEndpointData,
    "MongodbEndpointDataResource": MongodbEndpointDataResource,
    "MysqlEndpointData": MysqlEndpointData,
    "MysqlEndpointDataResource": MysqlEndpointDataResource,
    "ObjectRelationData": ObjectRelationData,
    "ObjectRelationDataRelation": ObjectRelationDataRelation,
    "OdataRestEndpointData": OdataRestEndpointData,
    "OdataRestEndpointDataResource": OdataRestEndpointDataResource,
    "OdataRestEndpointDataResourceBasic": OdataRestEndpointDataResourceBasic,
    "OdataRestEndpointDataResourceOauth2": OdataRestEndpointDataResourceOauth2,
    "PdoEndpointData": PdoEndpointData,
    "PdoEndpointDataResource": PdoEndpointDataResource,
    "ProcessStatus": ProcessStatus,
    "Resource": Resource,
    "SecretMount": SecretMount,
    "Storage": Storage,
    "UcsEndpointData": UcsEndpointData,
    "UcsEndpointDataResource": UcsEndpointDataResource,
    "UserData": UserData,
    "WorkflowData": WorkflowData,
    "XmlEndpointData": XmlEndpointData,
    "XmlEndpointDataResource": XmlEndpointDataResource,
    "AccessRole": AccessRole,
    "AccessRoles": AccessRoles,
    "AccessRule": AccessRule,
    "AccessRules": AccessRules,
    "Collection": Collection,
    "Collections": Collections,
    "DataObject": DataObject,
    "DataObjects": DataObjects,
    "Endpoint": Endpoint,
    "EndpointObject": EndpointObject,
    "EndpointObjects": EndpointObjects,
    "Endpoints": Endpoints,
    "Job": Job,
    "Jobs": Jobs,
    "Log": Log,
    "Logs": Logs,
    "Namespace": Namespace,
    "Namespaces": Namespaces,
    "ObjectRelation": ObjectRelation,
    "ObjectRelations": ObjectRelations,
    "Processes": Processes,
    "Secret": Secret,
    "Secrets": Secrets,
    "User": User,
    "Users": Users,
    "Workflow": Workflow,
    "Workflows": Workflows,
    "BalloonEndpoint": BalloonEndpoint,
    "CsvEndpoint": CsvEndpoint,
    "JsonEndpoint": JsonEndpoint,
    "LdapEndpoint": LdapEndpoint,
    "MongodbEndpoint": MongodbEndpoint,
    "MysqlEndpoint": MysqlEndpoint,
    "OdataRestEndpoint": OdataRestEndpoint,
    "PdoEndpoint": PdoEndpoint,
    "Process": Process,
    "UcsEndpoint": UcsEndpoint,
    "XmlEndpoint": XmlEndpoint,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum V1ApiApiKeys {
}

export class V1Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V1ApiApiKeys, value: string) {
        (this.authentications as any)[V1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new access role
     * @param data 
     */
    public addAccessRole (data?: AccessRole) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new access rule
     * @param data 
     */
    public addAccessRule (data?: AccessRule) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add collection
     * @param namespace Namespace name
     * @param data 
     */
    public addCollection (namespace: string, data?: Collection) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add Endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public addEndpoint (namespace: string, collection: string, data?: any) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new job
     * @param namespace Namespace name
     * @param data 
     */
    public addJob (namespace: string, data?: Job) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Job")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add namespace
     * @param data 
     */
    public addNamespace (data?: Namespace) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Namespace")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new object of a specifc collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public addObject (namespace: string, collection: string, data?: DataObject) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Trigger a new process
     * @param namespace Namespace name
     * @param data 
     */
    public addProcess (namespace: string, data?: Process) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Process")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new object relation
     * @param namespace Namespace name
     * @param data 
     */
    public addRelation (namespace: string, data?: ObjectRelation) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "ObjectRelation")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new secret
     * @param namespace Namespace name
     * @param data 
     */
    public addSecret (namespace: string, data?: Secret) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new User
     * @param data 
     */
    public addUser (data?: User) : any {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add worfklow to endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data 
     */
    public addWorkflow (namespace: string, collection: string, endpoint: string, data?: Workflow) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling addWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-role by name
     * @param access_role Access role name
     */
    public deleteAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling deleteAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-rule by name
     * @param access_rule Access rule name
     */
    public deleteAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling deleteAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific collection
     * @param namespace Namespace name
     * @param collection Collection
     */
    public deleteCollection (namespace: string, collection: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     */
    public deleteEndpoint (namespace: string, collection: string, endpoint: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete job by id
     * @param namespace Namespace name
     * @param job Job ID
     */
    public deleteJob (namespace: string, job: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling deleteJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific namespace
     * @param namespace Namespace name
     */
    public deleteNamespace (namespace: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a specific object
     * @summary Delete object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     */
    public deleteObject (namespace: string, collection: string, object: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete object relation
     * @param namespace Namespace name
     * @param relation Relation
     */
    public deleteObjectRelation (namespace: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteObjectRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling deleteObjectRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Abort running process
     * @param namespace Namespace name
     * @param process Process ID
     */
    public deleteProcess (namespace: string, process: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteProcess.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling deleteProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete secret by name
     * @param namespace Namespace name
     * @param secret secret name
     */
    public deleteSecret (namespace: string, secret: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling deleteSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete User by name
     * @param User User name
     */
    public deleteUser (User: string) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling deleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific workflow from
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     */
    public deleteWorkflow (namespace: string, collection: string, endpoint: string, workflow: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling deleteWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access role by name
     * @param access_role Access role name
     */
    public getAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling getAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access role defines what role is granted access to what resource
     * @summary Get access roles
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getAccessRoles (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access rule by name
     * @param access_rule Access rule name
     */
    public getAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling getAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access rule defines what role is granted access to what resource
     * @summary Get access rules
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getAccessRules (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRules;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get api entrypoint
     */
    public getApi () : any {
        const localVarPath = this.basePath + '/api';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A collection is collection of dataobjects of a specific type
     * @summary Get specific collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param attributes Filter attributes
     */
    public getCollection (namespace: string, collection: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollection.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single collection log
     * @param namespace Namespace name
     * @param collection Collection
     * @param log Log id
     */
    public getCollectionLog (namespace: string, collection: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollectionLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollectionLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getCollectionLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getCollectionLogs (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollectionLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollectionLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A collection is collection of data objects of a specific type
     * @summary Get collections
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getCollections (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollections.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collections;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collections");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get specific endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param attributes Filter attributes
     */
    public getEndpoint (namespace: string, collection: string, endpoint: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpoint.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single endpoint log
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param log Log id
     */
    public getEndpointLog (namespace: string, collection: string, endpoint: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getEndpointLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of an endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpointLogs (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointLogs.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get objects from endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpointObjects (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: EndpointObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EndpointObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get endpoints
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpoints (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpoints.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get job by id
     * @param namespace Namespace name
     * @param job Job ID
     */
    public getJob (namespace: string, job: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single job error
     * @param namespace Namespace name
     * @param job Job ID
     * @param log Log id
     */
    public getJobLog (namespace: string, job: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobLog.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getJobLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a job
     * @param namespace Namespace name
     * @param job Job ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getJobLogs (namespace: string, job: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobLogs.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A job is an asynchronous server process
     * @summary Get list of active queued jobs
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getJobs (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Jobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Jobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A namespace is a logical group of collections
     * @summary Get specific namespace
     * @param namespace Namespace name
     * @param attributes Filter attributes
     */
    public getNamespace (namespace: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getNamespace.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A namespace is a logical group of collections
     * @summary Get namespaces
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getNamespaces (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Namespaces;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Namespaces");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an object of a specific collection
     * @summary Get specific object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param attributes Filter attributes
     */
    public getObject (namespace: string, collection: string, object: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObject.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the history of all modifications from a specific object
     * @summary Get object history
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectHistory (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/history'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectHistory.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single object log
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param log Log id
     */
    public getObjectLog (namespace: string, collection: string, object: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getObjectLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectLogs (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectLogs.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relative object of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object name
     * @param relation Relation name
     */
    public getObjectRelation (namespace: string, collection: string, object: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling getObjectRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all objects the object is related to
     * @summary Get relative objects of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectRelations (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectRelations.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectRelations.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelations.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A object is a data object from a specifc collection
     * @summary Get objects of a specific collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjects (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjects.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process of a job
     * @param namespace Namespace name
     * @param process Process ID
     */
    public getProcess (namespace: string, process: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcess.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process log
     * @param namespace Namespace name
     * @param process Process ID
     * @param log Log id
     */
    public getProcessLog (namespace: string, process: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/process/{process}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcessLog.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getProcessLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a process
     * @param namespace Namespace name
     * @param process Process ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getProcessLogs (namespace: string, process: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcessLogs.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all processes
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getProcesses (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcesses.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Processes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Processes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relation
     * @param namespace Namespace name
     * @param relation Relation
     */
    public getRelation (namespace: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling getRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get data object relations
     * @summary Get data object relations
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getRelations (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getRelations.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get secret by name
     * @param namespace Namespace name
     * @param secret secret name
     */
    public getSecret (namespace: string, secret: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling getSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An secret holds secret data which should not get exposed and is specially encrypted on the server. A secret can be injected into other resources.
     * @summary Get secrets
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getSecrets (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getSecrets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Secrets;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secrets");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get User by name
     * @param User User name
     */
    public getUser (User: string) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling getUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An User defines what role is granted access to what resource
     * @summary Get users
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getUsers (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get api entrypoint
     */
    public getV1 () : any {
        const localVarPath = this.basePath + '/api/v1';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a collection and with what attribute map
     * @summary Get specifc endpoint workflow
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param attributes Filter attributes
     */
    public getWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling getWorkflow.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a collection and with what attribute map
     * @summary Get endpoint workflows
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getWorkflows (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflows;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflows");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access role
     * @param access_role Access role name
     * @param data 
     */
    public replaceAccessRole (access_role: string, data?: AccessRole) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling replaceAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access rule
     * @param access_rule Access rule name
     * @param data 
     */
    public replaceAccessRule (access_rule: string, data?: AccessRule) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling replaceAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public replaceCollection (namespace: string, collection: string, data?: Collection) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace endppoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data 
     */
    public replaceEndpoint (namespace: string, collection: string, endpoint: string, data?: Endpoint) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Endpoint")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace namespace
     * @param namespace Namespace name
     * @param data 
     */
    public replaceNamespace (namespace: string, data?: Namespace) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Namespace")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace all data attributes of an object (Or create one if not exists)
     * @summary Replace or create object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data 
     */
    public replaceObject (namespace: string, collection: string, object: string, write?: boolean, data?: DataObject) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling replaceObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace object relation
     * @param namespace Namespace name
     * @param relation Relation
     * @param data 
     */
    public replaceRelation (namespace: string, relation: string, data?: ObjectRelation) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling replaceRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "ObjectRelation")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an secret
     * @param namespace Namespace name
     * @param secret secret name
     * @param data 
     */
    public replaceSecret (namespace: string, secret: string, data?: Secret) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling replaceSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an User
     * @param User User name
     * @param data 
     */
    public replaceUser (User: string, data?: User) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling replaceUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace workflow
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data 
     */
    public replaceWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, data?: Workflow) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling replaceWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access role as rfc6902 request
     * @param access_role Access role name
     * @param job Access role json patch
     */
    public updateAccessRole (access_role: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling updateAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access rule as rfc6902 request
     * @param access_rule Access rule name
     * @param job Access rule json patch
     */
    public updateAccessRule (access_rule: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling updateAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a collection
     * @summary Patch collection as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param data Collection
     */
    public updateCollection (namespace: string, collection: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a endpoint
     * @summary Patch collection as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data Collection
     */
    public updateEndpoint (namespace: string, collection: string, endpoint: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a job
     * @summary Patch job as rfc6902 request
     * @param namespace Namespace name
     * @param job Job ID
     * @param data Object
     */
    public updateJob (namespace: string, job: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling updateJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a namespace
     * @summary Patch namespace as rfc6902 request
     * @param namespace Namespace name
     * @param data Namespace
     */
    public updateNamespace (namespace: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of an object
     * @summary Patch object as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param data Object
     */
    public updateObject (namespace: string, collection: string, object: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a relation
     * @summary Patch relation as rfc6902 request
     * @param namespace Namespace name
     * @param relation Relation
     * @param data Object
     */
    public updateRelation (namespace: string, relation: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling updateRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch secret as rfc6902 request
     * @param namespace Namespace name
     * @param secret secret name
     * @param job secret json patch
     */
    public updateSecret (namespace: string, secret: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling updateSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch User as rfc6902 request
     * @param User User name
     * @param job User json patch
     */
    public updateUser (User: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling updateUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a workflow
     * @summary Patch workflow as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data Workflow
     */
    public updateWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling updateWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
