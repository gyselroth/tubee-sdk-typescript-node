/**
 * Tubee API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.2.2
 * Contact: opensource@gyselroth.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
export {localVarRequest};
import http = require('http');
import Promise = require('bluebird');

export const specPath = __dirname+'/../swagger.yml';

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class CoreV1AccessRoleData {
    /**
    * A list of user identifiers which the access role should match. It is also possible to specify a wildcard to match all identifiers.
    */
    'selectors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRoleData.attributeTypeMap;
    }
}

export class CoreV1AccessRuleData {
    /**
    * A list of access-role names to match the given rule.
    */
    'roles'?: Array<string>;
    /**
    * List of allowed HTTP rfc7231 verbs, you may also specify a wildcard to match all verbs.
    */
    'verbs'?: Array<CoreV1AccessRuleData.VerbsEnum>;
    /**
    * A list of selectors to match resources, for example namespace, collection, endpoint, ...
    */
    'selectors'?: Array<string>;
    /**
    * Values according to your selector list required to match a request.
    */
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        },
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<CoreV1AccessRuleData.VerbsEnum>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRuleData.attributeTypeMap;
    }
}

export namespace CoreV1AccessRuleData {
    export enum VerbsEnum {
        Star = <any> '*',
        GET = <any> 'GET',
        POST = <any> 'POST',
        PUT = <any> 'PUT',
        PATCH = <any> 'PATCH',
        DELETE = <any> 'DELETE',
        HEAD = <any> 'HEAD'
    }
}
export class CoreV1AttributeMap {
    /**
    * Attribute map
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AttributeMap.attributeTypeMap;
    }
}

export class CoreV1BalloonEndpointData {
    'resource': CoreV1BalloonEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1BalloonEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1BalloonEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1BalloonEndpointDataResource {
    /**
    * Base uri to resources (Like https://rest.api/v2/users).
    */
    'base_uri': string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    /**
    * Authentication adapter, either of none, http basic authentication or oauth2 using client_credentials flow.
    */
    'auth'?: CoreV1BalloonEndpointDataResource.AuthEnum;
    'basic'?: CoreV1OdataRestEndpointDataResourceBasic;
    'oauth2'?: CoreV1BalloonEndpointDataResourceOauth2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "CoreV1BalloonEndpointDataResource.AuthEnum"
        },
        {
            "name": "basic",
            "baseName": "basic",
            "type": "CoreV1OdataRestEndpointDataResourceBasic"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "CoreV1BalloonEndpointDataResourceOauth2"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1BalloonEndpointDataResource.attributeTypeMap;
    }
}

export namespace CoreV1BalloonEndpointDataResource {
    export enum AuthEnum {
        Basic = <any> 'basic',
        Oauth2 = <any> 'oauth2'
    }
}
/**
* Oauth2 client credentials flow. auth must be set to oauth2 if this adapter should be used.
*/
export class CoreV1BalloonEndpointDataResourceOauth2 {
    /**
    * URI to token endpoint.
    */
    'token_uri'?: string;
    /**
    * OAuth2 client_id.
    */
    'client_id'?: string;
    /**
    * OAuth2 client_secret. Note the client_secret gets encrypted on the server an can't be retrieved after it.
    */
    'client_secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token_uri",
            "baseName": "token_uri",
            "type": "string"
        },
        {
            "name": "client_id",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "client_secret",
            "baseName": "client_secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1BalloonEndpointDataResourceOauth2.attributeTypeMap;
    }
}

export class CoreV1CollectionData {
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1CollectionData.attributeTypeMap;
    }
}

export class CoreV1CsvEndpointData {
    'storage'?: CoreV1Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;
    'resource'?: CoreV1CsvEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "CoreV1Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1CsvEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1CsvEndpointData.attributeTypeMap;
    }
}

/**
* CSV parse options.
*/
export class CoreV1CsvEndpointDataResource {
    /**
    * Field delimiter.
    */
    'delimiter'?: string;
    /**
    * Field enclosure.
    */
    'enclosure'?: string;
    /**
    * Escape character.
    */
    'escape'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "delimiter",
            "baseName": "delimiter",
            "type": "string"
        },
        {
            "name": "enclosure",
            "baseName": "enclosure",
            "type": "string"
        },
        {
            "name": "escape",
            "baseName": "escape",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1CsvEndpointDataResource.attributeTypeMap;
    }
}

export class CoreV1EndpointData {
    /**
    * Specify the type of the endpoint.
    */
    'type'?: CoreV1EndpointData.TypeEnum;
    'options'?: CoreV1EndpointDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreV1EndpointData.TypeEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "CoreV1EndpointDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1EndpointData.attributeTypeMap;
    }
}

export namespace CoreV1EndpointData {
    export enum TypeEnum {
        Browse = <any> 'browse',
        Source = <any> 'source',
        Destination = <any> 'destination',
        Bidirectional = <any> 'bidirectional'
    }
}
export class CoreV1EndpointDataOptions {
    /**
    * Endpoint resource identifier.
    */
    'identifier'?: string;
    /**
    * A list of attributes which gets used to uniquely identify an object on the endpoint.
    */
    'import'?: Array<string>;
    /**
    * If true and the endpoint is of type source, the endpoint gets flushed before export. If the type is destination, the endpoints collection gets flushed before import. Pay attention with flush as it may result in data loss!
    */
    'flush'?: boolean;
    /**
    * Specify an endpoint filter which gets used to filter for a single object.
    */
    'filter_one'?: string;
    /**
    * Specify a filter which always gets applied to the endpoint if objects are retrieved.
    */
    'filter_all'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "import",
            "baseName": "import",
            "type": "Array<string>"
        },
        {
            "name": "flush",
            "baseName": "flush",
            "type": "boolean"
        },
        {
            "name": "filter_one",
            "baseName": "filter_one",
            "type": "string"
        },
        {
            "name": "filter_all",
            "baseName": "filter_all",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1EndpointDataOptions.attributeTypeMap;
    }
}

export class CoreV1JobData {
    'notification'?: CoreV1JobDataNotification;
    /**
    * A list of collections (name) the job should match. You may use a wildcard to specify all collections. Each element may contain either a single collection name or a list of collections. A list will be processed in parallel while single collections get synchronized syncronely
    */
    'collections'?: Array<string>;
    /**
    * A list of endoints (name) the job should match. You may use a wildcard to specify all endpoints. Each element may contain either a single endpoint name or a list of endpoints. A list will be processed in parallel while single endpoints get synchronized syncronely.
    */
    'endpoints'?: Array<string>;
    /**
    * Data object filter (JSON encoded).
    */
    'filter'?: string;
    /**
    * If enabled the server does ignores any sync errors and continue with the process.
    */
    'ignore'?: boolean;
    /**
    * Simulate sync (Do not apply any changes)
    */
    'simulate'?: boolean;
    /**
    * You may change the log level which gets applied during a sync job. Note that a log level too verbose has a big impact on the sync performance.
    */
    'log_level'?: CoreV1JobData.LogLevelEnum;
    'options'?: CoreV1JobDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notification",
            "baseName": "notification",
            "type": "CoreV1JobDataNotification"
        },
        {
            "name": "collections",
            "baseName": "collections",
            "type": "Array<string>"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "string"
        },
        {
            "name": "ignore",
            "baseName": "ignore",
            "type": "boolean"
        },
        {
            "name": "simulate",
            "baseName": "simulate",
            "type": "boolean"
        },
        {
            "name": "log_level",
            "baseName": "log_level",
            "type": "CoreV1JobData.LogLevelEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "CoreV1JobDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JobData.attributeTypeMap;
    }
}

export namespace CoreV1JobData {
    export enum LogLevelEnum {
        Emerg = <any> 'emerg',
        Error = <any> 'error',
        Warn = <any> 'warn',
        Info = <any> 'info',
        Notice = <any> 'notice',
        Debug = <any> 'debug'
    }
}
export class CoreV1JobDataNotification {
    /**
    * You may enable mail notification for a given job.
    */
    'enabled'?: boolean;
    /**
    * A list of mail adresses which the notification should be sent to. This option has no affect if notification is disabled.
    */
    'receiver'?: Array<string>;
    /**
    * A list of dataobject attributes which should be added to the notification mail when dataobject can't be synced. This option has no affect if notification is disabled.
    */
    'identifier'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "receiver",
            "baseName": "receiver",
            "type": "Array<string>"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JobDataNotification.attributeTypeMap;
    }
}

/**
* Holds options about when a job should start and with what interval.
*/
export class CoreV1JobDataOptions {
    /**
    * Holds a unix timestamp at what time the job should be executed.
    */
    'at'?: string;
    /**
    * The number of seconds after the job should be executed again. The default is only run once.
    */
    'interval'?: number;
    /**
    * You may specify if the interval refers to the start or the end of the previous job. The default is 'end' which means the interval refers to the end time of the previous job. When you define 'start' the interval refers to the start time of the previous job. The default is 'end'.
    */
    'interval_reference'?: CoreV1JobDataOptions.IntervalReferenceEnum;
    /**
    * The number of times a failed job should be restarted. The default is never.
    */
    'retry'?: number;
    /**
    * The number of seconds between failed job retries. The default is 300 (5min).
    */
    'retry_interval'?: number;
    /**
    * Maximum runtime of a job (process). By default there is no timeout. This option should be handled carefully.
    */
    'timeout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "at",
            "baseName": "at",
            "type": "string"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "interval_reference",
            "baseName": "interval_reference",
            "type": "CoreV1JobDataOptions.IntervalReferenceEnum"
        },
        {
            "name": "retry",
            "baseName": "retry",
            "type": "number"
        },
        {
            "name": "retry_interval",
            "baseName": "retry_interval",
            "type": "number"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JobDataOptions.attributeTypeMap;
    }
}

export namespace CoreV1JobDataOptions {
    export enum IntervalReferenceEnum {
        Start = <any> 'start',
        End = <any> 'end'
    }
}
export class CoreV1JsonEndpointData {
    'storage'?: CoreV1Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "CoreV1Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JsonEndpointData.attributeTypeMap;
    }
}

/**
* A JSON Patch according rfc6902.
*/
export class CoreV1JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JsonPatch.attributeTypeMap;
    }
}

export class CoreV1LdapEndpointData {
    'resource'?: CoreV1LdapEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1LdapEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1LdapEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1LdapEndpointDataResource {
    /**
    * A full LDAP URI of the form ldap://hostname:port or ldaps://hostname:port for SSL encryption.
    */
    'uri'?: string;
    /**
    * Bind DN if required.
    */
    'binddn'?: string;
    /**
    * Bind password if required.
    */
    'bindpw'?: string;
    /**
    * Specifies the base dn (Like dc=example,dc=net).
    */
    'basedn'?: string;
    /**
    * Set to true if TLS shall be used.
    */
    'tls'?: boolean;
    /**
    * More ldap specific settings (http://php.net/manual/en/function.ldap-set-option.php).
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "binddn",
            "baseName": "binddn",
            "type": "string"
        },
        {
            "name": "bindpw",
            "baseName": "bindpw",
            "type": "string"
        },
        {
            "name": "basedn",
            "baseName": "basedn",
            "type": "string"
        },
        {
            "name": "tls",
            "baseName": "tls",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1LdapEndpointDataResource.attributeTypeMap;
    }
}

export class CoreV1Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Link.attributeTypeMap;
    }
}

/**
* Contains resource links (URL) to other resources.
*/
export class CoreV1Links {
    'self'?: CoreV1Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "CoreV1Link"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Links.attributeTypeMap;
    }
}

export class CoreV1List {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1List.attributeTypeMap;
    }
}

export class CoreV1ListLinks {
    'self'?: CoreV1Link;
    'prev'?: CoreV1Link;
    'next'?: CoreV1Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "CoreV1Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "CoreV1Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "CoreV1Link"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ListLinks.attributeTypeMap;
    }
}

export class CoreV1LogData {
    'level'?: number;
    'level_name'?: string;
    /**
    * The log message.
    */
    'message'?: string;
    /**
    * The server component which logged the message.
    */
    'category'?: string;
    /**
    * Holds an exception object if the log message holds an exception reference.
    */
    'exception'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "level_name",
            "baseName": "level_name",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "exception",
            "baseName": "exception",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1LogData.attributeTypeMap;
    }
}

export class CoreV1MongodbEndpointData {
    /**
    * The name of the MongoDB database where the collection is located at.
    */
    'database'?: string;
    /**
    * The name of the MongoDB collection where the data is located at.
    */
    'collection'?: string;
    'resource'?: CoreV1MongodbEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "database",
            "baseName": "database",
            "type": "string"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1MongodbEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MongodbEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1MongodbEndpointDataResource {
    /**
    * MongoDB connection uri
    */
    'uri'?: string;
    /**
    * Advanced URI options
    */
    'uri_options'?: any;
    /**
    * Advanced Driver options
    */
    'driver_options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "uri_options",
            "baseName": "uri_options",
            "type": "any"
        },
        {
            "name": "driver_options",
            "baseName": "driver_options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MongodbEndpointDataResource.attributeTypeMap;
    }
}

export class CoreV1MysqlEndpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: CoreV1MysqlEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1MysqlEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MysqlEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1MysqlEndpointDataResource {
    /**
    * MySQL Server (Or compatible MySQL fork like MariaDB).
    */
    'host'?: string;
    /**
    * Username.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'passwd'?: string;
    /**
    * Specifies the port number to attempt to connect to the MySQL server.
    */
    'port'?: number;
    /**
    * Specifies the socket or named pipe that should be used.
    */
    'socket'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "socket",
            "baseName": "socket",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MysqlEndpointDataResource.attributeTypeMap;
    }
}

export class CoreV1ObjectRelationData {
    /**
    * Optional context context data which describes the relationship.
    */
    'context'?: any;
    /**
    * Holds the relationship between two objects. You may create cross collection and cross namespace object relationships.
    */
    'relation'?: Array<CoreV1ObjectRelationDataRelation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        },
        {
            "name": "relation",
            "baseName": "relation",
            "type": "Array<CoreV1ObjectRelationDataRelation>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ObjectRelationData.attributeTypeMap;
    }
}

export class CoreV1ObjectRelationDataRelation {
    /**
    * Name of the objects namespace
    */
    'namespace'?: string;
    /**
    * Name of the objects collection
    */
    'collection'?: string;
    /**
    * Name of the object
    */
    'object'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ObjectRelationDataRelation.attributeTypeMap;
    }
}

export class CoreV1OdataRestEndpointData {
    'resource'?: CoreV1OdataRestEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1OdataRestEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1OdataRestEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1OdataRestEndpointDataResource {
    /**
    * Base uri to resources (Like https://rest.api/v1/resources).
    */
    'base_uri'?: string;
    /**
    * Key of array which contains the data in REST response
    */
    'container'?: string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    /**
    * Authentication adapter, either of none, http basic authentication or oauth2 using client_credentials flow.
    */
    'auth'?: CoreV1OdataRestEndpointDataResource.AuthEnum;
    'basic'?: CoreV1OdataRestEndpointDataResourceBasic;
    'oauth2'?: CoreV1OdataRestEndpointDataResourceOauth2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "container",
            "baseName": "container",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "CoreV1OdataRestEndpointDataResource.AuthEnum"
        },
        {
            "name": "basic",
            "baseName": "basic",
            "type": "CoreV1OdataRestEndpointDataResourceBasic"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "CoreV1OdataRestEndpointDataResourceOauth2"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1OdataRestEndpointDataResource.attributeTypeMap;
    }
}

export namespace CoreV1OdataRestEndpointDataResource {
    export enum AuthEnum {
        Basic = <any> 'basic',
        Oauth2 = <any> 'oauth2'
    }
}
/**
* HTTP Basic authentication. auth must be set to basic if this adapter should be used.
*/
export class CoreV1OdataRestEndpointDataResourceBasic {
    /**
    * Basic authentication username.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1OdataRestEndpointDataResourceBasic.attributeTypeMap;
    }
}

/**
* Oauth2 client credentials flow. auth must be set to oauth2 if this adapter should be used.
*/
export class CoreV1OdataRestEndpointDataResourceOauth2 {
    /**
    * URI to token endpoint.
    */
    'token_endpoint'?: string;
    /**
    * OAuth2 client_id.
    */
    'client_id'?: string;
    /**
    * OAuth2 client_secret. Note the client_secret gets encrypted on the server an can't be retrieved after it.
    */
    'client_secret'?: string;
    /**
    * OAuth2 scopes
    */
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token_endpoint",
            "baseName": "token_endpoint",
            "type": "string"
        },
        {
            "name": "client_id",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "client_secret",
            "baseName": "client_secret",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1OdataRestEndpointDataResourceOauth2.attributeTypeMap;
    }
}

export class CoreV1PdoEndpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: CoreV1PdoEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1PdoEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1PdoEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1PdoEndpointDataResource {
    /**
    * Data source name (DSN).
    */
    'dsn'?: string;
    /**
    * Username if required.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'passwd'?: string;
    /**
    * Driver specific connection options.
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dsn",
            "baseName": "dsn",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1PdoEndpointDataResource.attributeTypeMap;
    }
}

/**
* Holds the status of this resource. Note that status is immutable.
*/
export class CoreV1ProcessStatus {
    /**
    * The result code of the process.
    */
    'code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ProcessStatus.attributeTypeMap;
    }
}

export class CoreV1Resource {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Resource.attributeTypeMap;
    }
}

export class CoreV1SecretMount {
    /**
    * The name of the secret from which the key's value should be injected.
    */
    'secret'?: string;
    /**
    * The name of the key which should be taken from a secret (You may use a recursive path by delimiting keys with '.', for example: password).
    */
    'key'?: string;
    /**
    * The resource path where the secret value should be injected (You may use a recursive path by delimiting keys with '.', for example: data.resource.password).
    */
    'to'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1SecretMount.attributeTypeMap;
    }
}

export class CoreV1SqlSrvUsersEndpointData {
    'resource'?: CoreV1SqlSrvUsersEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1SqlSrvUsersEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1SqlSrvUsersEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1SqlSrvUsersEndpointDataResource {
    /**
    * MSSQL Server.
    */
    'host'?: string;
    /**
    * Username if required.
    */
    'username'?: string;
    /**
    * Password if required.
    */
    'password'?: string;
    /**
    * Database.
    */
    'dbname'?: string;
    /**
    * Specifies the port number to attempt to connect to the MSSQL server.
    */
    'port'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "dbname",
            "baseName": "dbname",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1SqlSrvUsersEndpointDataResource.attributeTypeMap;
    }
}

/**
* The storage defines where data can be fetched.
*/
export class CoreV1Storage {
    /**
    * The kind of storage where data shall be fetched.
    */
    'kind'?: CoreV1Storage.KindEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "CoreV1Storage.KindEnum"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Storage.attributeTypeMap;
    }
}

export namespace CoreV1Storage {
    export enum KindEnum {
        Stream = <any> 'Stream',
        LocalFilesystem = <any> 'LocalFilesystem',
        Smb = <any> 'Smb',
        Balloon = <any> 'Balloon'
    }
}
export class CoreV1UcsEndpointData {
    'resource'?: CoreV1UcsEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1UcsEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1UcsEndpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class CoreV1UcsEndpointDataResource {
    /**
    * Base uri to univention server (usually including /univention) (Like https://master/univention).
    */
    'base_uri'?: string;
    /**
    * Object type flavor (For example users/user or groups/group).
    */
    'flavor'?: string;
    /**
    * Advanced request options, see http://docs.guzzlephp.org/en/stable/request-options.html
    */
    'request_options'?: any;
    'auth'?: CoreV1OdataRestEndpointDataResourceBasic;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "flavor",
            "baseName": "flavor",
            "type": "string"
        },
        {
            "name": "request_options",
            "baseName": "request_options",
            "type": "any"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "CoreV1OdataRestEndpointDataResourceBasic"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1UcsEndpointDataResource.attributeTypeMap;
    }
}

/**
* The user information.
*/
export class CoreV1UserData {
    /**
    * The users password. Gets hashed on the server and can not be retrieved after.
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1UserData.attributeTypeMap;
    }
}

export class CoreV1WorkflowData {
    /**
    * The priority defines in what order multiple workflows get executed. 0 (Default) is the highest priority.
    */
    'priority'?: number;
    'ensure'?: CoreV1WorkflowData.EnsureEnum;
    /**
    * Holds a scripted condition if a given workflow gets matched and executed.
    */
    'condition'?: string;
    /**
    * Map attributes from the endpoint to the collection schema (if the endpoint is of type source) or map attributes from the collection to the endpoint if the endpoint is of type destination.
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "ensure",
            "baseName": "ensure",
            "type": "CoreV1WorkflowData.EnsureEnum"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1WorkflowData.attributeTypeMap;
    }
}

export namespace CoreV1WorkflowData {
    export enum EnsureEnum {
        Last = <any> 'last',
        Exists = <any> 'exists',
        Absent = <any> 'absent',
        Merge = <any> 'merge'
    }
}
export class CoreV1XmlEndpointData {
    'storage'?: CoreV1Storage;
    /**
    * File uri or pattern, depends what storage you have choosen.
    */
    'file'?: string;
    'resource'?: CoreV1XmlEndpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storage",
            "baseName": "storage",
            "type": "CoreV1Storage"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "CoreV1XmlEndpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1XmlEndpointData.attributeTypeMap;
    }
}

/**
* CSV parse options.
*/
export class CoreV1XmlEndpointDataResource {
    /**
    * The name of the root element.
    */
    'root_name'?: string;
    /**
    * The name of the sub node of the root element. For example: <root><row><a>0</a></row><a>1</a><row></row</root>
    */
    'node_name'?: string;
    /**
    * Prettify xml output, note this is only useful if the XmlEndpoint is a destination endpoint.
    */
    'pretty'?: boolean;
    /**
    * Preserve whitespace, note this is only useful if the XmlEndpoint is a destination endpoint.
    */
    'preserve_whitespace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "root_name",
            "baseName": "root_name",
            "type": "string"
        },
        {
            "name": "node_name",
            "baseName": "node_name",
            "type": "string"
        },
        {
            "name": "pretty",
            "baseName": "pretty",
            "type": "boolean"
        },
        {
            "name": "preserve_whitespace",
            "baseName": "preserve_whitespace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1XmlEndpointDataResource.attributeTypeMap;
    }
}

/**
* An access role is defined list which matches authenticated user identifiers.
*/
export class CoreV1AccessRole {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always AccessRole.
    */
    'kind'?: string;
    'data'?: CoreV1AccessRoleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1AccessRoleData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRole.attributeTypeMap;
    }
}

/**
* A list of access roles.
*/
export class CoreV1AccessRoles {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1AccessRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1AccessRole>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRoles.attributeTypeMap;
    }
}

/**
* An access rule allows to specify what access roles can access which resources.
*/
export class CoreV1AccessRule {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always AccessRule.
    */
    'kind'?: string;
    'data'?: CoreV1AccessRuleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1AccessRuleData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRule.attributeTypeMap;
    }
}

/**
* A list of access rules.
*/
export class CoreV1AccessRules {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1AccessRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1AccessRule>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1AccessRules.attributeTypeMap;
    }
}

/**
* A collection is a collection of data objects, meaning a collection of similar objects.
*/
export class CoreV1Collection {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Collection.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: CoreV1CollectionData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1CollectionData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Collection.attributeTypeMap;
    }
}

/**
* A list of collections.
*/
export class CoreV1Collections {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Collections>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Collections>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Collections.attributeTypeMap;
    }
}

/**
* A data object represents a single object in a collection (data collection).
*/
export class CoreV1DataObject {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always DataObject.
    */
    'kind'?: string;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1DataObject.attributeTypeMap;
    }
}

/**
* List of data objects.
*/
export class CoreV1DataObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1DataObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1DataObject>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1DataObjects.attributeTypeMap;
    }
}

/**
* An endpoint represents an external resource to browse (proxy), import or export. This may be a database, a file, a http service, ...
*/
export class CoreV1Endpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint.
    */
    'kind'?: CoreV1Endpoint.KindEnum;
    'data'?: CoreV1EndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "CoreV1Endpoint.KindEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1EndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Endpoint.attributeTypeMap;
    }
}

export namespace CoreV1Endpoint {
    export enum KindEnum {
        PdoEndpoint = <any> 'PdoEndpoint',
        MysqlEndpoint = <any> 'MysqlEndpoint',
        XmlEndpoint = <any> 'XmlEndpoint',
        CsvEndpoint = <any> 'CsvEndpoint',
        ImageEndpoint = <any> 'ImageEndpoint',
        JsonEndpoint = <any> 'JsonEndpoint',
        MongodbEndpoint = <any> 'MongodbEndpoint',
        MoodleEndpoint = <any> 'MoodleEndpoint',
        BalloonEndpoint = <any> 'BalloonEndpoint',
        OdataRestEndpoint = <any> 'OdataRestEndpoint',
        UcsEndpoint = <any> 'UcsEndpoint',
        SqlSrvUsersEndpoint = <any> 'SqlSrvUsersEndpoint'
    }
}
/**
* An endpoint object is the actual object on an endpoint itself.
*/
export class CoreV1EndpointObject {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1EndpointObject.attributeTypeMap;
    }
}

/**
* A list of endpoint objects.
*/
export class CoreV1EndpointObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always EndpointObject.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1EndpointObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1EndpointObject>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1EndpointObjects.attributeTypeMap;
    }
}

/**
* A list of endpoints.
*/
export class CoreV1Endpoints {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Endpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Endpoint>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Endpoints.attributeTypeMap;
    }
}

/**
* A job is a synchronization job which declares when and what collections should be synchronized.
*/
export class CoreV1Job {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Job.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: CoreV1JobData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1JobData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Job.attributeTypeMap;
    }
}

/**
* A list of jobs.
*/
export class CoreV1Jobs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Job>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Job>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Jobs.attributeTypeMap;
    }
}

/**
* A log messagage from a process.
*/
export class CoreV1Log {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Log.
    */
    'kind'?: string;
    'data'?: CoreV1LogData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1LogData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Log.attributeTypeMap;
    }
}

/**
* A list of logs.
*/
export class CoreV1Logs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Log>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Log>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Logs.attributeTypeMap;
    }
}

/**
* A namespace is a namespace to separate resources.
*/
export class CoreV1Namespace {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Namespace.
    */
    'kind'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Namespace.attributeTypeMap;
    }
}

/**
* A list of namespaces.
*/
export class CoreV1Namespaces {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Namespace>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Namespace>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Namespaces.attributeTypeMap;
    }
}

/**
* An object relation represents a releationship between two data objects. A relationship may apply to objects of different collections and/or namespaces.
*/
export class CoreV1ObjectRelation {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always DataObjectRelation.
    */
    'kind'?: string;
    'data'?: CoreV1ObjectRelationData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1ObjectRelationData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ObjectRelation.attributeTypeMap;
    }
}

/**
* A list of relations.
*/
export class CoreV1ObjectRelations {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1ObjectRelation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1ObjectRelation>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1ObjectRelations.attributeTypeMap;
    }
}

/**
* A list of processes.
*/
export class CoreV1Processes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Process>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Process>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Processes.attributeTypeMap;
    }
}

/**
* A secret is sensitive information which can be injected into another resource. A secret gets specially encrypted on the server and is always base64 encoded.
*/
export class CoreV1Secret {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Secret.
    */
    'kind'?: string;
    /**
    * The secrets data. You may specify multiple keys. Important: You need to base64 encode the values!
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Secret.attributeTypeMap;
    }
}

/**
* A list of secrets.
*/
export class CoreV1Secrets {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Secret>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Secret>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Secrets.attributeTypeMap;
    }
}

/**
* A local tubee user.
*/
export class CoreV1User {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always User.
    */
    'kind'?: string;
    'data'?: CoreV1UserData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1UserData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1User.attributeTypeMap;
    }
}

/**
* A list of users.
*/
export class CoreV1Users {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1User>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Users.attributeTypeMap;
    }
}

/**
* A workflow gets used if an endpoint gets imported or exported. A workflow defines if and what object and also if and what attributes of an object should be written to or from an endpoint.
*/
export class CoreV1Workflow {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Workflow.
    */
    'kind'?: string;
    'data'?: CoreV1WorkflowData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1WorkflowData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Workflow.attributeTypeMap;
    }
}

/**
* A list of workflows.
*/
export class CoreV1Workflows {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV1ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV1Workflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV1Workflow>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Workflows.attributeTypeMap;
    }
}

/**
* Balloon cloud server endpoint
*/
export class CoreV1BalloonEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always BalloonEndpoint.
    */
    'kind': string;
    'data': CoreV1BalloonEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1BalloonEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1BalloonEndpoint.attributeTypeMap;
    }
}

/**
* CSV data format endpoint
*/
export class CoreV1CsvEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always CsvEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1CsvEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1CsvEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1CsvEndpoint.attributeTypeMap;
    }
}

/**
* JSON data format endpoint
*/
export class CoreV1JsonEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always JsonEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1JsonEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1JsonEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1JsonEndpoint.attributeTypeMap;
    }
}

/**
* LDAP (OpenLDAP, Microsoft AD and other LDAP compatible Server) endpoint
*/
export class CoreV1LdapEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always LdapEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1LdapEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1LdapEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1LdapEndpoint.attributeTypeMap;
    }
}

/**
* MongoDB endpoint
*/
export class CoreV1MongodbEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always MongodbEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1MongodbEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1MongodbEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MongodbEndpoint.attributeTypeMap;
    }
}

/**
* MySQL/MariaDB (and other MySQL forks) endpoint
*/
export class CoreV1MysqlEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always MysqlEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1MysqlEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1MysqlEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1MysqlEndpoint.attributeTypeMap;
    }
}

/**
* OData REST API endpoint (Compatible with Microsoft graph (Office365 and more) and other OData compatible api's)
*/
export class CoreV1OdataRestEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always OdataRestEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1OdataRestEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1OdataRestEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1OdataRestEndpoint.attributeTypeMap;
    }
}

/**
* Pdo endpoint
*/
export class CoreV1PdoEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always PdoEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1PdoEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1PdoEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1PdoEndpoint.attributeTypeMap;
    }
}

/**
* A process is a sub resource of a job. Each process represents one job execution.
*/
export class CoreV1Process {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The resource type, always Process.
    */
    'kind'?: string;
    /**
    * The resource namespace
    */
    'namespace'?: string;
    'data'?: CoreV1JobData;
    'status'?: CoreV1ProcessStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1JobData"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "CoreV1ProcessStatus"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1Process.attributeTypeMap;
    }
}

/**
* MSSQL User endpoint
*/
export class CoreV1SqlSrvUsersEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always SqlSrvUsersEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1SqlSrvUsersEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1SqlSrvUsersEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1SqlSrvUsersEndpoint.attributeTypeMap;
    }
}

/**
* UCS endpoint (Univention Corporate Server, https://www.univention.com/products/ucs)
*/
export class CoreV1UcsEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always UcsEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1UcsEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1UcsEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1UcsEndpoint.attributeTypeMap;
    }
}

/**
* XML data format endpoint
*/
export class CoreV1XmlEndpoint {
    '_links'?: CoreV1Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server and must be unique in its own resource context.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Injected secrets in this resource.
    */
    'secrets'?: Array<CoreV1SecretMount>;
    /**
    * The type of endpoint. Always XmlEndpoint.
    */
    'kind'?: string;
    'data'?: CoreV1XmlEndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV1Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreV1SecretMount>"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CoreV1XmlEndpointData"
        }    ];

    static getAttributeTypeMap() {
        return CoreV1XmlEndpoint.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "CoreV1AccessRuleData.VerbsEnum": CoreV1AccessRuleData.VerbsEnum,
        "CoreV1BalloonEndpointDataResource.AuthEnum": CoreV1BalloonEndpointDataResource.AuthEnum,
        "CoreV1EndpointData.TypeEnum": CoreV1EndpointData.TypeEnum,
        "CoreV1JobData.LogLevelEnum": CoreV1JobData.LogLevelEnum,
        "CoreV1JobDataOptions.IntervalReferenceEnum": CoreV1JobDataOptions.IntervalReferenceEnum,
        "CoreV1OdataRestEndpointDataResource.AuthEnum": CoreV1OdataRestEndpointDataResource.AuthEnum,
        "CoreV1Storage.KindEnum": CoreV1Storage.KindEnum,
        "CoreV1WorkflowData.EnsureEnum": CoreV1WorkflowData.EnsureEnum,
        "CoreV1Endpoint.KindEnum": CoreV1Endpoint.KindEnum,
}

let typeMap: {[index: string]: any} = {
    "CoreV1AccessRoleData": CoreV1AccessRoleData,
    "CoreV1AccessRuleData": CoreV1AccessRuleData,
    "CoreV1AttributeMap": CoreV1AttributeMap,
    "CoreV1BalloonEndpointData": CoreV1BalloonEndpointData,
    "CoreV1BalloonEndpointDataResource": CoreV1BalloonEndpointDataResource,
    "CoreV1BalloonEndpointDataResourceOauth2": CoreV1BalloonEndpointDataResourceOauth2,
    "CoreV1CollectionData": CoreV1CollectionData,
    "CoreV1CsvEndpointData": CoreV1CsvEndpointData,
    "CoreV1CsvEndpointDataResource": CoreV1CsvEndpointDataResource,
    "CoreV1EndpointData": CoreV1EndpointData,
    "CoreV1EndpointDataOptions": CoreV1EndpointDataOptions,
    "CoreV1JobData": CoreV1JobData,
    "CoreV1JobDataNotification": CoreV1JobDataNotification,
    "CoreV1JobDataOptions": CoreV1JobDataOptions,
    "CoreV1JsonEndpointData": CoreV1JsonEndpointData,
    "CoreV1JsonPatch": CoreV1JsonPatch,
    "CoreV1LdapEndpointData": CoreV1LdapEndpointData,
    "CoreV1LdapEndpointDataResource": CoreV1LdapEndpointDataResource,
    "CoreV1Link": CoreV1Link,
    "CoreV1Links": CoreV1Links,
    "CoreV1List": CoreV1List,
    "CoreV1ListLinks": CoreV1ListLinks,
    "CoreV1LogData": CoreV1LogData,
    "CoreV1MongodbEndpointData": CoreV1MongodbEndpointData,
    "CoreV1MongodbEndpointDataResource": CoreV1MongodbEndpointDataResource,
    "CoreV1MysqlEndpointData": CoreV1MysqlEndpointData,
    "CoreV1MysqlEndpointDataResource": CoreV1MysqlEndpointDataResource,
    "CoreV1ObjectRelationData": CoreV1ObjectRelationData,
    "CoreV1ObjectRelationDataRelation": CoreV1ObjectRelationDataRelation,
    "CoreV1OdataRestEndpointData": CoreV1OdataRestEndpointData,
    "CoreV1OdataRestEndpointDataResource": CoreV1OdataRestEndpointDataResource,
    "CoreV1OdataRestEndpointDataResourceBasic": CoreV1OdataRestEndpointDataResourceBasic,
    "CoreV1OdataRestEndpointDataResourceOauth2": CoreV1OdataRestEndpointDataResourceOauth2,
    "CoreV1PdoEndpointData": CoreV1PdoEndpointData,
    "CoreV1PdoEndpointDataResource": CoreV1PdoEndpointDataResource,
    "CoreV1ProcessStatus": CoreV1ProcessStatus,
    "CoreV1Resource": CoreV1Resource,
    "CoreV1SecretMount": CoreV1SecretMount,
    "CoreV1SqlSrvUsersEndpointData": CoreV1SqlSrvUsersEndpointData,
    "CoreV1SqlSrvUsersEndpointDataResource": CoreV1SqlSrvUsersEndpointDataResource,
    "CoreV1Storage": CoreV1Storage,
    "CoreV1UcsEndpointData": CoreV1UcsEndpointData,
    "CoreV1UcsEndpointDataResource": CoreV1UcsEndpointDataResource,
    "CoreV1UserData": CoreV1UserData,
    "CoreV1WorkflowData": CoreV1WorkflowData,
    "CoreV1XmlEndpointData": CoreV1XmlEndpointData,
    "CoreV1XmlEndpointDataResource": CoreV1XmlEndpointDataResource,
    "CoreV1AccessRole": CoreV1AccessRole,
    "CoreV1AccessRoles": CoreV1AccessRoles,
    "CoreV1AccessRule": CoreV1AccessRule,
    "CoreV1AccessRules": CoreV1AccessRules,
    "CoreV1Collection": CoreV1Collection,
    "CoreV1Collections": CoreV1Collections,
    "CoreV1DataObject": CoreV1DataObject,
    "CoreV1DataObjects": CoreV1DataObjects,
    "CoreV1Endpoint": CoreV1Endpoint,
    "CoreV1EndpointObject": CoreV1EndpointObject,
    "CoreV1EndpointObjects": CoreV1EndpointObjects,
    "CoreV1Endpoints": CoreV1Endpoints,
    "CoreV1Job": CoreV1Job,
    "CoreV1Jobs": CoreV1Jobs,
    "CoreV1Log": CoreV1Log,
    "CoreV1Logs": CoreV1Logs,
    "CoreV1Namespace": CoreV1Namespace,
    "CoreV1Namespaces": CoreV1Namespaces,
    "CoreV1ObjectRelation": CoreV1ObjectRelation,
    "CoreV1ObjectRelations": CoreV1ObjectRelations,
    "CoreV1Processes": CoreV1Processes,
    "CoreV1Secret": CoreV1Secret,
    "CoreV1Secrets": CoreV1Secrets,
    "CoreV1User": CoreV1User,
    "CoreV1Users": CoreV1Users,
    "CoreV1Workflow": CoreV1Workflow,
    "CoreV1Workflows": CoreV1Workflows,
    "CoreV1BalloonEndpoint": CoreV1BalloonEndpoint,
    "CoreV1CsvEndpoint": CoreV1CsvEndpoint,
    "CoreV1JsonEndpoint": CoreV1JsonEndpoint,
    "CoreV1LdapEndpoint": CoreV1LdapEndpoint,
    "CoreV1MongodbEndpoint": CoreV1MongodbEndpoint,
    "CoreV1MysqlEndpoint": CoreV1MysqlEndpoint,
    "CoreV1OdataRestEndpoint": CoreV1OdataRestEndpoint,
    "CoreV1PdoEndpoint": CoreV1PdoEndpoint,
    "CoreV1Process": CoreV1Process,
    "CoreV1SqlSrvUsersEndpoint": CoreV1SqlSrvUsersEndpoint,
    "CoreV1UcsEndpoint": CoreV1UcsEndpoint,
    "CoreV1XmlEndpoint": CoreV1XmlEndpoint,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CoreV1ApiApiKeys {
}

export class CoreV1Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CoreV1ApiApiKeys, value: string) {
        (this.authentications as any)[CoreV1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new access role
     * @param data 
     */
    public addAccessRole (data?: CoreV1AccessRole) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new access rule
     * @param data 
     */
    public addAccessRule (data?: CoreV1AccessRule) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add collection
     * @param namespace Namespace name
     * @param data 
     */
    public addCollection (namespace: string, data?: CoreV1Collection) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add Endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public addEndpoint (namespace: string, collection: string, data?: any) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new job
     * @param namespace Namespace name
     * @param data 
     */
    public addJob (namespace: string, data?: CoreV1Job) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Job")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add namespace
     * @param data 
     */
    public addNamespace (data?: CoreV1Namespace) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Namespace")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new object of a specifc collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public addObject (namespace: string, collection: string, data?: CoreV1DataObject) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Trigger a new process
     * @param namespace Namespace name
     * @param data 
     */
    public addProcess (namespace: string, data?: CoreV1Process) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Process")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new object relation
     * @param namespace Namespace name
     * @param data 
     */
    public addRelation (namespace: string, data?: CoreV1ObjectRelation) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1ObjectRelation")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new secret
     * @param namespace Namespace name
     * @param data 
     */
    public addSecret (namespace: string, data?: CoreV1Secret) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new User
     * @param data 
     */
    public addUser (data?: CoreV1User) : any {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add worfklow to endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data 
     */
    public addWorkflow (namespace: string, collection: string, endpoint: string, data?: CoreV1Workflow) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling addWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-role by name
     * @param access_role Access role name
     */
    public deleteAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling deleteAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-rule by name
     * @param access_rule Access rule name
     */
    public deleteAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling deleteAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific collection
     * @param namespace Namespace name
     * @param collection Collection
     */
    public deleteCollection (namespace: string, collection: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     */
    public deleteEndpoint (namespace: string, collection: string, endpoint: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete job by id
     * @param namespace Namespace name
     * @param job Job ID
     */
    public deleteJob (namespace: string, job: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling deleteJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific namespace
     * @param namespace Namespace name
     */
    public deleteNamespace (namespace: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a specific object
     * @summary Delete object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     */
    public deleteObject (namespace: string, collection: string, object: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete object relation
     * @param namespace Namespace name
     * @param relation Relation
     */
    public deleteObjectRelation (namespace: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteObjectRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling deleteObjectRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Abort running process
     * @param namespace Namespace name
     * @param process Process ID
     */
    public deleteProcess (namespace: string, process: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteProcess.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling deleteProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete secret by name
     * @param namespace Namespace name
     * @param secret secret name
     */
    public deleteSecret (namespace: string, secret: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling deleteSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete User by name
     * @param User User name
     */
    public deleteUser (User: string) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling deleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific workflow from
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     */
    public deleteWorkflow (namespace: string, collection: string, endpoint: string, workflow: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling deleteWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access role by name
     * @param access_role Access role name
     */
    public getAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling getAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access role defines what role is granted access to what resource
     * @summary Get access roles
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getAccessRoles (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access rule by name
     * @param access_rule Access rule name
     */
    public getAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling getAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access rule defines what role is granted access to what resource
     * @summary Get access rules
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getAccessRules (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRules;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get api entrypoint
     */
    public getApi () : any {
        const localVarPath = this.basePath + '/api';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A collection is collection of dataobjects of a specific type
     * @summary Get specific collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param attributes Filter attributes
     */
    public getCollection (namespace: string, collection: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollection.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single collection log
     * @param namespace Namespace name
     * @param collection Collection
     * @param log Log id
     */
    public getCollectionLog (namespace: string, collection: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollectionLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollectionLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getCollectionLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getCollectionLogs (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollectionLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getCollectionLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A collection is collection of data objects of a specific type
     * @summary Get collections
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getCollections (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getCollections.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Collections;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Collections");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get specific endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param attributes Filter attributes
     */
    public getEndpoint (namespace: string, collection: string, endpoint: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpoint.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single endpoint log
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param log Log id
     */
    public getEndpointLog (namespace: string, collection: string, endpoint: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getEndpointLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of an endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpointLogs (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointLogs.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get objects from endpoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpointObjects (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1EndpointObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1EndpointObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get endpoints
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getEndpoints (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getEndpoints.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Endpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Endpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get job by id
     * @param namespace Namespace name
     * @param job Job ID
     */
    public getJob (namespace: string, job: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single job error
     * @param namespace Namespace name
     * @param job Job ID
     * @param log Log id
     */
    public getJobLog (namespace: string, job: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobLog.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getJobLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a job
     * @param namespace Namespace name
     * @param job Job ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getJobLogs (namespace: string, job: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobLogs.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A job is an asynchronous server process
     * @summary Get list of active queued jobs
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getJobs (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getJobs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Jobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Jobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A namespace is a logical group of collections
     * @summary Get specific namespace
     * @param namespace Namespace name
     * @param attributes Filter attributes
     */
    public getNamespace (namespace: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getNamespace.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A namespace is a logical group of collections
     * @summary Get namespaces
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getNamespaces (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Namespaces;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Namespaces");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an object of a specific collection
     * @summary Get specific object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param attributes Filter attributes
     */
    public getObject (namespace: string, collection: string, object: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObject.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the history of all modifications from a specific object
     * @summary Get object history
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectHistory (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/history'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectHistory.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single object log
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param log Log id
     */
    public getObjectLog (namespace: string, collection: string, object: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getObjectLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectLogs (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectLogs.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectLogs.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relative object of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object name
     * @param relation Relation name
     */
    public getObjectRelation (namespace: string, collection: string, object: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling getObjectRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all objects the object is related to
     * @summary Get relative objects of an object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjectRelations (namespace: string, collection: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjectRelations.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjectRelations.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelations.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A object is a data object from a specifc collection
     * @summary Get objects of a specific collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getObjects (namespace: string, collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getObjects.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process of a job
     * @param namespace Namespace name
     * @param process Process ID
     */
    public getProcess (namespace: string, process: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcess.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process log
     * @param namespace Namespace name
     * @param process Process ID
     * @param log Log id
     */
    public getProcessLog (namespace: string, process: string, log: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/process/{process}/logs/{log}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcessLog.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getProcessLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a process
     * @param namespace Namespace name
     * @param process Process ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getProcessLogs (namespace: string, process: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes/{process}/logs'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcessLogs.');
        }

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all processes
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getProcesses (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/processes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getProcesses.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Processes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Processes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relation
     * @param namespace Namespace name
     * @param relation Relation
     */
    public getRelation (namespace: string, relation: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling getRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get data object relations
     * @summary Get data object relations
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getRelations (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getRelations.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get secret by name
     * @param namespace Namespace name
     * @param secret secret name
     */
    public getSecret (namespace: string, secret: string) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling getSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An secret holds secret data which should not get exposed and is specially encrypted on the server. A secret can be injected into other resources.
     * @summary Get secrets
     * @param namespace Namespace name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getSecrets (namespace: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getSecrets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Secrets;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Secrets");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get User by name
     * @param User User name
     */
    public getUser (User: string) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling getUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An User defines what role is granted access to what resource
     * @summary Get users
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getUsers (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get api entrypoint
     */
    public getV1 () : any {
        const localVarPath = this.basePath + '/api/v1';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a collection and with what attribute map
     * @summary Get specifc endpoint workflow
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param attributes Filter attributes
     */
    public getWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling getWorkflow.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a collection and with what attribute map
     * @summary Get endpoint workflows
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param stream Stream resources. There is no limit by default.
     * @param watch Watch resources. By default a stream and useful to retrieve UPDATE, DELETE and ADD updates.
     */
    public getWorkflows (namespace: string, collection: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, stream?: boolean, watch?: boolean) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stream !== undefined) {
            localVarQueryParameters['stream'] = ObjectSerializer.serialize(stream, "boolean");
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Workflows;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Workflows");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access role
     * @param access_role Access role name
     * @param data 
     */
    public replaceAccessRole (access_role: string, data?: CoreV1AccessRole) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling replaceAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access rule
     * @param access_rule Access rule name
     * @param data 
     */
    public replaceAccessRule (access_rule: string, data?: CoreV1AccessRule) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling replaceAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace collection
     * @param namespace Namespace name
     * @param collection Collection
     * @param data 
     */
    public replaceCollection (namespace: string, collection: string, data?: CoreV1Collection) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace endppoint
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data 
     */
    public replaceEndpoint (namespace: string, collection: string, endpoint: string, data?: CoreV1Endpoint) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Endpoint")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace namespace
     * @param namespace Namespace name
     * @param data 
     */
    public replaceNamespace (namespace: string, data?: CoreV1Namespace) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Namespace")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace all data attributes of an object (Or create one if not exists)
     * @summary Replace or create object
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data 
     */
    public replaceObject (namespace: string, collection: string, object: string, write?: boolean, data?: CoreV1DataObject) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling replaceObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace object relation
     * @param namespace Namespace name
     * @param relation Relation
     * @param data 
     */
    public replaceRelation (namespace: string, relation: string, data?: CoreV1ObjectRelation) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling replaceRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1ObjectRelation")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an secret
     * @param namespace Namespace name
     * @param secret secret name
     * @param data 
     */
    public replaceSecret (namespace: string, secret: string, data?: CoreV1Secret) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling replaceSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an User
     * @param User User name
     * @param data 
     */
    public replaceUser (User: string, data?: CoreV1User) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling replaceUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace workflow
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data 
     */
    public replaceWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, data?: CoreV1Workflow) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling replaceWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV1Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access role as rfc6902 request
     * @param access_role Access role name
     * @param job Access role json patch
     */
    public updateAccessRole (access_role: string, job?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling updateAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access rule as rfc6902 request
     * @param access_rule Access rule name
     * @param job Access rule json patch
     */
    public updateAccessRule (access_rule: string, job?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling updateAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a collection
     * @summary Patch collection as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param data Collection
     */
    public updateCollection (namespace: string, collection: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateCollection.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a endpoint
     * @summary Patch collection as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param data Collection
     */
    public updateEndpoint (namespace: string, collection: string, endpoint: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a job
     * @summary Patch job as rfc6902 request
     * @param namespace Namespace name
     * @param job Job ID
     * @param data Object
     */
    public updateJob (namespace: string, job: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/jobs/{job}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateJob.');
        }

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling updateJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a namespace
     * @summary Patch namespace as rfc6902 request
     * @param namespace Namespace name
     * @param data Namespace
     */
    public updateNamespace (namespace: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateNamespace.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Namespace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Namespace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of an object
     * @summary Patch object as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param object Object ID
     * @param data Object
     */
    public updateObject (namespace: string, collection: string, object: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/objects/{object}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateObject.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a relation
     * @summary Patch relation as rfc6902 request
     * @param namespace Namespace name
     * @param relation Relation
     * @param data Object
     */
    public updateRelation (namespace: string, relation: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/relations/{relation}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'relation' + '}', encodeURIComponent(String(relation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateRelation.');
        }

        // verify required parameter 'relation' is not null or undefined
        if (relation === null || relation === undefined) {
            throw new Error('Required parameter relation was null or undefined when calling updateRelation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1ObjectRelation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1ObjectRelation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch secret as rfc6902 request
     * @param namespace Namespace name
     * @param secret secret name
     * @param job secret json patch
     */
    public updateSecret (namespace: string, secret: string, job?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{secret}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateSecret.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling updateSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch User as rfc6902 request
     * @param User User name
     * @param job User json patch
     */
    public updateUser (User: string, job?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/users/{User}'
            .replace('{' + 'User' + '}', encodeURIComponent(String(User)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'User' is not null or undefined
        if (User === null || User === undefined) {
            throw new Error('Required parameter User was null or undefined when calling updateUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a workflow
     * @summary Patch workflow as rfc6902 request
     * @param namespace Namespace name
     * @param collection Collection
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data Workflow
     */
    public updateWorkflow (namespace: string, collection: string, endpoint: string, workflow: string, data?: Array<CoreV1JsonPatch>) : any {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/collections/{collection}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling updateWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<CoreV1JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV1Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV1Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
