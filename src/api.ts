/**
 * Tubee API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: opensource@gyselroth.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

export const specPath = __dirname+'/../swagger.yml';

let defaultBasePath = 'https://localhost/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessroleData {
    /**
    * A list of user identifiers which the access role should match. It is also possible to specify a wildcard to match all identifiers.
    */
    'selectors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessroleData.attributeTypeMap;
    }
}

export class AccessruleData {
    /**
    * A list of access-role names to match the given rule.
    */
    'roles'?: Array<string>;
    /**
    * List of allowed HTTP rfc7231 verbs, you may also specify a wildcard to match all verbs.
    */
    'verbs'?: Array<AccessruleData.VerbsEnum>;
    /**
    * A list of selectors to match resources, for example mandator, datatype, endpoint, ...
    */
    'selectors'?: Array<string>;
    /**
    * Values according to your selector list required to match a request.
    */
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        },
        {
            "name": "verbs",
            "baseName": "verbs",
            "type": "Array<AccessruleData.VerbsEnum>"
        },
        {
            "name": "selectors",
            "baseName": "selectors",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AccessruleData.attributeTypeMap;
    }
}

export namespace AccessruleData {
    export enum VerbsEnum {
        Star = <any> '*',
        GET = <any> 'GET',
        POST = <any> 'POST',
        PUT = <any> 'PUT',
        PATCH = <any> 'PATCH',
        DELETE = <any> 'DELETE',
        HEAD = <any> 'HEAD'
    }
}
export class AttributeMap {
    '_links'?: Links;
    'kind'?: string;
    'datatype'?: Datatype;
    'mandator'?: Mandator;
    'workflow'?: Workflow;
    /**
    * Name of implementation, usually Tubee\\AttributeMap
    */
    'class'?: string;
    /**
    * Attribute map
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "datatype",
            "baseName": "datatype",
            "type": "Datatype"
        },
        {
            "name": "mandator",
            "baseName": "mandator",
            "type": "Mandator"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AttributeMap.attributeTypeMap;
    }
}

export class DatatypeData {
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DatatypeData.attributeTypeMap;
    }
}

export class EndpointData {
    /**
    * The implementation of the endpoint
    */
    'class'?: EndpointData.ModelClassEnum;
    /**
    * Specify the type of the endpoint.
    */
    'type'?: EndpointData.TypeEnum;
    'options'?: EndpointDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "class",
            "type": "EndpointData.ModelClassEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "EndpointData.TypeEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "EndpointDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return EndpointData.attributeTypeMap;
    }
}

export namespace EndpointData {
    export enum ModelClassEnum {
        Pdo = <any> 'Pdo',
        Mysql = <any> 'Mysql',
        Xml = <any> 'Xml',
        Csv = <any> 'Csv',
        Image = <any> 'Image',
        Json = <any> 'Json',
        MongoDB = <any> 'MongoDB',
        Moodle = <any> 'Moodle',
        Balloon = <any> 'Balloon'
    }
    export enum TypeEnum {
        Virtual = <any> 'virtual',
        Source = <any> 'source',
        Destination = <any> 'destination',
        Bidirectional = <any> 'bidirectional'
    }
}
export class EndpointDataOptions {
    /**
    * A list of attributes which gets used to uniquely identify an object on the endpoint.
    */
    'identifier'?: Array<string>;
    /**
    * A list of attributes which gets used to uniquely identify an object on the endpoint.
    */
    'import'?: Array<string>;
    /**
    * If true and the endpoint is of type source, the endpoint gets flushed before export. If the type is destination, the endpoints datatype gets flushed before import. Pay attention with flush as it may result in data loss!
    */
    'flush'?: boolean;
    /**
    * Specify an endpoint filter which gets used to filter for a single object.
    */
    'filter_one'?: any;
    /**
    * Specify a filter which always gets applied to the endpoint if objects are retrieved.
    */
    'filter_all'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "Array<string>"
        },
        {
            "name": "import",
            "baseName": "import",
            "type": "Array<string>"
        },
        {
            "name": "flush",
            "baseName": "flush",
            "type": "boolean"
        },
        {
            "name": "filter_one",
            "baseName": "filter_one",
            "type": "any"
        },
        {
            "name": "filter_all",
            "baseName": "filter_all",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return EndpointDataOptions.attributeTypeMap;
    }
}

export class JobData {
    'notification'?: JobDataNotification;
    /**
    * A list of mandators (name) the job should match. You may use a wildcard to specify all mandators.
    */
    'mandators'?: Array<string>;
    /**
    * A list of datatypes (name) the job should match. You may use a wildcard to specify all datatypes.
    */
    'datatypes'?: Array<string>;
    /**
    * A list of endoints (name) the job should match. You may use a wildcard to specify all endpoints.
    */
    'endpoints'?: Array<string>;
    /**
    * Data object filter.
    */
    'filter'?: any;
    /**
    * If enabled the server tries to splitt the job into multiple parallel processes.
    */
    'loadbalance'?: boolean;
    /**
    * If enabled the server does ignores any sync errors and continue with the process.
    */
    'ignore'?: boolean;
    /**
    * You may change the log level which gets applied during a sync job. Note that a log level too verbose has a big impact on the sync performance.
    */
    'log_level'?: JobData.LogLevelEnum;
    'options'?: JobDataOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notification",
            "baseName": "notification",
            "type": "JobDataNotification"
        },
        {
            "name": "mandators",
            "baseName": "mandators",
            "type": "Array<string>"
        },
        {
            "name": "datatypes",
            "baseName": "datatypes",
            "type": "Array<string>"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<string>"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "loadbalance",
            "baseName": "loadbalance",
            "type": "boolean"
        },
        {
            "name": "ignore",
            "baseName": "ignore",
            "type": "boolean"
        },
        {
            "name": "log_level",
            "baseName": "log_level",
            "type": "JobData.LogLevelEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "JobDataOptions"
        }    ];

    static getAttributeTypeMap() {
        return JobData.attributeTypeMap;
    }
}

export namespace JobData {
    export enum LogLevelEnum {
        Emerg = <any> 'emerg',
        Error = <any> 'error',
        Warn = <any> 'warn',
        Info = <any> 'info',
        Notice = <any> 'notice',
        Debug = <any> 'debug'
    }
}
export class JobDataNotification {
    /**
    * You may enable mail notification for a given job.
    */
    'enabled'?: boolean;
    /**
    * A list of mail adresses which the notification should be sent to. This option has no affect if notification is disabled.
    */
    'receiver'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "receiver",
            "baseName": "receiver",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return JobDataNotification.attributeTypeMap;
    }
}

/**
* Holds options about when a job should start and with what interval.
*/
export class JobDataOptions {
    /**
    * Holds a unix timestamp at what time the job should be executed.
    */
    'at'?: string;
    /**
    * The number of secconds after the job should be executed again. The default is only run once.
    */
    'interval'?: number;
    /**
    * The number of times a failed job should be restarted. The default is never.
    */
    'retry'?: number;
    /**
    * The number of secconds beween failed job retries. The default is 300 (5min).
    */
    'retry_interval'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "at",
            "baseName": "at",
            "type": "string"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "retry",
            "baseName": "retry",
            "type": "number"
        },
        {
            "name": "retry_interval",
            "baseName": "retry_interval",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDataOptions.attributeTypeMap;
    }
}

/**
* A JSON Patch according rfc6902.
*/
export class JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JsonPatch.attributeTypeMap;
    }
}

export class LdapendpointData {
    'resource'?: LdapendpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "LdapendpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return LdapendpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class LdapendpointDataResource {
    /**
    * A full LDAP URI of the form ldap://hostname:port or ldaps://hostname:port for SSL encryption.
    */
    'uri'?: string;
    /**
    * Bind DN if required.
    */
    'binddn'?: string;
    /**
    * Bind password if required. Note the password gets encrypted on the server an can't be retrieved after it. If a password was set, has_password will be true.
    */
    'bindpw'?: string;
    /**
    * Is true if a password has been set.
    */
    'has_password'?: boolean;
    /**
    * Specifies the base dn (Like dc=example,dc=net).
    */
    'basedn'?: string;
    /**
    * Set to true if TLS shall be used.
    */
    'tls'?: boolean;
    /**
    * More ldap specific settings (http://php.net/manual/en/function.ldap-set-option.php).
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "binddn",
            "baseName": "binddn",
            "type": "string"
        },
        {
            "name": "bindpw",
            "baseName": "bindpw",
            "type": "string"
        },
        {
            "name": "has_password",
            "baseName": "has_password",
            "type": "boolean"
        },
        {
            "name": "basedn",
            "baseName": "basedn",
            "type": "string"
        },
        {
            "name": "tls",
            "baseName": "tls",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LdapendpointDataResource.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

/**
* Contains resource links (URL) to other resources.
*/
export class Links {
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class List {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return List.attributeTypeMap;
    }
}

export class ListLinks {
    'self'?: Link;
    'prev'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return ListLinks.attributeTypeMap;
    }
}

export class LogData {
    'level'?: number;
    'level_name'?: string;
    /**
    * The log message.
    */
    'message'?: string;
    /**
    * The server component which logged the message.
    */
    'category'?: string;
    /**
    * Holds an exception object if the log message holds an exception reference.
    */
    'exception'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "level_name",
            "baseName": "level_name",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "exception",
            "baseName": "exception",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LogData.attributeTypeMap;
    }
}

export class MysqlendpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: MysqlendpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "MysqlendpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return MysqlendpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class MysqlendpointDataResource {
    /**
    * MySQL Server (Or compatible MySQL fork like MariaDB).
    */
    'host'?: string;
    /**
    * Username.
    */
    'username'?: string;
    /**
    * Password if required. Note the password gets encrypted on the server an can't be retrieved after it. If a password was set, has_password will be true.
    */
    'passwd'?: string;
    /**
    * Is true if a password has been set.
    */
    'has_password'?: boolean;
    /**
    * Specifies the port number to attempt to connect to the MySQL server.
    */
    'port'?: number;
    /**
    * Specifies the socket or named pipe that should be used.
    */
    'socket'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "has_password",
            "baseName": "has_password",
            "type": "boolean"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "socket",
            "baseName": "socket",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MysqlendpointDataResource.attributeTypeMap;
    }
}

export class ObjectrelativeData {
    /**
    * Optional context context data which describes the relationship.
    */
    'context'?: any;
    'object'?: DataObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "any"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "DataObject"
        }    ];

    static getAttributeTypeMap() {
        return ObjectrelativeData.attributeTypeMap;
    }
}

export class PdoendpointData {
    /**
    * Table or view
    */
    'table'?: string;
    'resource'?: PdoendpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "table",
            "baseName": "table",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "PdoendpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return PdoendpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class PdoendpointDataResource {
    /**
    * Data source name (DSN).
    */
    'dsn'?: string;
    /**
    * Username if required.
    */
    'username'?: string;
    /**
    * Password if required. Note the password gets encrypted on the server an can't be retrieved after it. If a password was set, has_password will be true.
    */
    'passwd'?: string;
    /**
    * Is true if a password has been set.
    */
    'has_password'?: boolean;
    /**
    * Driver specific connection options.
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dsn",
            "baseName": "dsn",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "passwd",
            "baseName": "passwd",
            "type": "string"
        },
        {
            "name": "has_password",
            "baseName": "has_password",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return PdoendpointDataResource.attributeTypeMap;
    }
}

/**
* Holds the status of this resource. Note that status is immutable.
*/
export class ProcessStatus {
    /**
    * The result code of the process.
    */
    'code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessStatus.attributeTypeMap;
    }
}

export class Resource {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Resource.attributeTypeMap;
    }
}

export class RestendpointData {
    'resource'?: RestendpointDataResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resource",
            "baseName": "resource",
            "type": "RestendpointDataResource"
        }    ];

    static getAttributeTypeMap() {
        return RestendpointData.attributeTypeMap;
    }
}

/**
* Holds the relevant options of how to connect to the endpoint.
*/
export class RestendpointDataResource {
    /**
    * Base uri to resourses (Like https://rest.api/v1/resources).
    */
    'base_uri'?: string;
    /**
    * Authentication adapter, either of none, http basic authentication or oauth2 using client_credentials flow.
    */
    'auth'?: RestendpointDataResource.AuthEnum;
    'basic'?: RestendpointDataResourceBasic;
    'oauth2'?: RestendpointDataResourceOauth2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base_uri",
            "baseName": "base_uri",
            "type": "string"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "RestendpointDataResource.AuthEnum"
        },
        {
            "name": "basic",
            "baseName": "basic",
            "type": "RestendpointDataResourceBasic"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "RestendpointDataResourceOauth2"
        }    ];

    static getAttributeTypeMap() {
        return RestendpointDataResource.attributeTypeMap;
    }
}

export namespace RestendpointDataResource {
    export enum AuthEnum {
        Basic = <any> 'basic',
        Oauth2 = <any> 'oauth2'
    }
}
/**
* HTTP Basic authentication. auth must be set to basic if this adapter should be used.
*/
export class RestendpointDataResourceBasic {
    /**
    * Basic authentication username.
    */
    'username'?: string;
    /**
    * Password if required. Note the password gets encrypted on the server an can't be retrieved after it. If a password was set, has_password will be true.
    */
    'password'?: string;
    /**
    * Is true if a password has been set.
    */
    'has_password'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "has_password",
            "baseName": "has_password",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RestendpointDataResourceBasic.attributeTypeMap;
    }
}

/**
* Oauth2 client credentials flow. auth must be set to oauth2 if this adapter should be used.
*/
export class RestendpointDataResourceOauth2 {
    /**
    * URI to token endpoint.
    */
    'token_uri'?: string;
    /**
    * OAuth2 client_id.
    */
    'client_id'?: string;
    /**
    * OAuth2 client_secret. Note the client_secret gets encrypted on the server an can't be retrieved after it.
    */
    'client_secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token_uri",
            "baseName": "token_uri",
            "type": "string"
        },
        {
            "name": "client_id",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "client_secret",
            "baseName": "client_secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestendpointDataResourceOauth2.attributeTypeMap;
    }
}

export class WorkflowData {
    'ensure'?: WorkflowData.EnsureEnum;
    /**
    * Holds a scripted condition if a given workflow gets matched and executed.
    */
    'condition'?: string;
    /**
    * Map attributes from the endpoint to the datatype schema (if the endpoint is of type source) or map attributes from the datatype to the endpoint if the endpoint is of type destination.
    */
    'map'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ensure",
            "baseName": "ensure",
            "type": "WorkflowData.EnsureEnum"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return WorkflowData.attributeTypeMap;
    }
}

export namespace WorkflowData {
    export enum EnsureEnum {
        Last = <any> 'last',
        Exists = <any> 'exists',
        Absent = <any> 'absent',
        Merge = <any> 'merge'
    }
}
/**
* An access role is defined list which matches authenticated user identifiers.
*/
export class AccessRole {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always AccessRole.
    */
    'kind'?: string;
    'data'?: AccessroleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AccessroleData"
        }    ];

    static getAttributeTypeMap() {
        return AccessRole.attributeTypeMap;
    }
}

/**
* A list of access roles.
*/
export class AccessRoles {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<AccessRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRole>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRoles.attributeTypeMap;
    }
}

/**
* An access rule allows to specify what access roles can access which resources.
*/
export class AccessRule {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always AccessRule.
    */
    'kind'?: string;
    'data'?: AccessruleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AccessruleData"
        }    ];

    static getAttributeTypeMap() {
        return AccessRule.attributeTypeMap;
    }
}

/**
* A list of access rules.
*/
export class AccessRules {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<AccessRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccessRule>"
        }    ];

    static getAttributeTypeMap() {
        return AccessRules.attributeTypeMap;
    }
}

/**
* A data object represents a single object in a datatype (data collection).
*/
export class DataObject {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always DataObject.
    */
    'kind'?: string;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DataObject.attributeTypeMap;
    }
}

/**
* List of data objects.
*/
export class DataObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<DataObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<DataObject>"
        }    ];

    static getAttributeTypeMap() {
        return DataObjects.attributeTypeMap;
    }
}

/**
* A datatype is a collection of data objects, meaning a collection of similar objects.
*/
export class Datatype {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always DataType.
    */
    'kind'?: string;
    'data'?: DatatypeData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "DatatypeData"
        }    ];

    static getAttributeTypeMap() {
        return Datatype.attributeTypeMap;
    }
}

/**
* A list of datatypes.
*/
export class Datatypes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Datatypes>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Datatypes>"
        }    ];

    static getAttributeTypeMap() {
        return Datatypes.attributeTypeMap;
    }
}

/**
* An endpoint represents an external resource with objects. This may be a database, a file, a http service, ...
*/
export class Endpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Endpoint.
    */
    'kind'?: string;
    'data'?: EndpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "EndpointData"
        }    ];

    static getAttributeTypeMap() {
        return Endpoint.attributeTypeMap;
    }
}

/**
* An endpoint object is the actual object on an endpoint itself.
*/
export class EndpointObject {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Attributes
    */
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return EndpointObject.attributeTypeMap;
    }
}

/**
* A list of endpoint objects.
*/
export class EndpointObjects {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always EndpointObject.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<EndpointObject>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<EndpointObject>"
        }    ];

    static getAttributeTypeMap() {
        return EndpointObjects.attributeTypeMap;
    }
}

/**
* A list of endpoints.
*/
export class Endpoints {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Endpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Endpoint>"
        }    ];

    static getAttributeTypeMap() {
        return Endpoints.attributeTypeMap;
    }
}

/**
* A job is a synchronization job which declares when and what datatypes should be synchronized.
*/
export class Job {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Job.
    */
    'kind'?: string;
    'data'?: JobData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "JobData"
        }    ];

    static getAttributeTypeMap() {
        return Job.attributeTypeMap;
    }
}

/**
* A list of jobs.
*/
export class Jobs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Job>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Job>"
        }    ];

    static getAttributeTypeMap() {
        return Jobs.attributeTypeMap;
    }
}

/**
* A log messagage from a process.
*/
export class Log {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Log.
    */
    'kind'?: string;
    'data'?: LogData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "LogData"
        }    ];

    static getAttributeTypeMap() {
        return Log.attributeTypeMap;
    }
}

/**
* A list of logs.
*/
export class Logs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Log>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Log>"
        }    ];

    static getAttributeTypeMap() {
        return Logs.attributeTypeMap;
    }
}

/**
* A mandator is a namespace to separate resources.
*/
export class Mandator {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Mandator.
    */
    'kind'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Mandator.attributeTypeMap;
    }
}

/**
* A list of mandators.
*/
export class Mandators {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Mandator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Mandator>"
        }    ];

    static getAttributeTypeMap() {
        return Mandators.attributeTypeMap;
    }
}

/**
* An object relation represents a releationship between two data objects. A relationship may apply to objects of different datatypes and/or mandators.
*/
export class ObjectRelative {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Mandator.
    */
    'kind'?: string;
    'data'?: ObjectrelativeData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "ObjectrelativeData"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelative.attributeTypeMap;
    }
}

/**
* A list of related objects.
*/
export class ObjectRelatives {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<ObjectRelative>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ObjectRelative>"
        }    ];

    static getAttributeTypeMap() {
        return ObjectRelatives.attributeTypeMap;
    }
}

/**
* A list of processes.
*/
export class Processes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Process>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Process>"
        }    ];

    static getAttributeTypeMap() {
        return Processes.attributeTypeMap;
    }
}

/**
* A workflow gets used if an endpoint gets imported or exported. A workflow defines if and what object and also if and what attributes of an object should be written to or from an endpoint.
*/
export class Workflow {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Workflow.
    */
    'kind'?: string;
    'data'?: WorkflowData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "WorkflowData"
        }    ];

    static getAttributeTypeMap() {
        return Workflow.attributeTypeMap;
    }
}

/**
* A list of workflows.
*/
export class Workflows {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Workflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Workflow>"
        }    ];

    static getAttributeTypeMap() {
        return Workflows.attributeTypeMap;
    }
}

/**
* LDAP (OpenLDAP, Microsoft AD and other LDAP compatible Server) endpoint
*/
export class LdapEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Endpoint.
    */
    'kind'?: string;
    'data'?: LdapendpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "LdapendpointData"
        }    ];

    static getAttributeTypeMap() {
        return LdapEndpoint.attributeTypeMap;
    }
}

/**
* MySQL/MariaDB (and other MySQL forks) endpoint
*/
export class MysqlEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Endpoint.
    */
    'kind'?: string;
    'data'?: MysqlendpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "MysqlendpointData"
        }    ];

    static getAttributeTypeMap() {
        return MysqlEndpoint.attributeTypeMap;
    }
}

/**
* Pdo endpoint
*/
export class PdoEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Endpoint.
    */
    'kind'?: string;
    'data'?: PdoendpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "PdoendpointData"
        }    ];

    static getAttributeTypeMap() {
        return PdoEndpoint.attributeTypeMap;
    }
}

/**
* A process is a sub resource of a job. Each process represents one job execution.
*/
export class Process {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Process.
    */
    'kind'?: string;
    'data'?: JobData;
    'status'?: ProcessStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "JobData"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ProcessStatus"
        }    ];

    static getAttributeTypeMap() {
        return Process.attributeTypeMap;
    }
}

/**
* Propper REST API endpoint
*/
export class RestEndpoint {
    '_links'?: Links;
    /**
    * Resource identifier. Note that the name is immutable once created on the server.
    */
    'name'?: string;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * The version of the resource. A version gets increased once the resource have been modified.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * The resource type, always Endpoint.
    */
    'kind'?: string;
    'data'?: RestendpointData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "RestendpointData"
        }    ];

    static getAttributeTypeMap() {
        return RestEndpoint.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AccessruleData.VerbsEnum": AccessruleData.VerbsEnum,
        "EndpointData.ModelClassEnum": EndpointData.ModelClassEnum,
        "EndpointData.TypeEnum": EndpointData.TypeEnum,
        "JobData.LogLevelEnum": JobData.LogLevelEnum,
        "RestendpointDataResource.AuthEnum": RestendpointDataResource.AuthEnum,
        "WorkflowData.EnsureEnum": WorkflowData.EnsureEnum,
}

let typeMap: {[index: string]: any} = {
    "AccessroleData": AccessroleData,
    "AccessruleData": AccessruleData,
    "AttributeMap": AttributeMap,
    "DatatypeData": DatatypeData,
    "EndpointData": EndpointData,
    "EndpointDataOptions": EndpointDataOptions,
    "JobData": JobData,
    "JobDataNotification": JobDataNotification,
    "JobDataOptions": JobDataOptions,
    "JsonPatch": JsonPatch,
    "LdapendpointData": LdapendpointData,
    "LdapendpointDataResource": LdapendpointDataResource,
    "Link": Link,
    "Links": Links,
    "List": List,
    "ListLinks": ListLinks,
    "LogData": LogData,
    "MysqlendpointData": MysqlendpointData,
    "MysqlendpointDataResource": MysqlendpointDataResource,
    "ObjectrelativeData": ObjectrelativeData,
    "PdoendpointData": PdoendpointData,
    "PdoendpointDataResource": PdoendpointDataResource,
    "ProcessStatus": ProcessStatus,
    "Resource": Resource,
    "RestendpointData": RestendpointData,
    "RestendpointDataResource": RestendpointDataResource,
    "RestendpointDataResourceBasic": RestendpointDataResourceBasic,
    "RestendpointDataResourceOauth2": RestendpointDataResourceOauth2,
    "WorkflowData": WorkflowData,
    "AccessRole": AccessRole,
    "AccessRoles": AccessRoles,
    "AccessRule": AccessRule,
    "AccessRules": AccessRules,
    "DataObject": DataObject,
    "DataObjects": DataObjects,
    "Datatype": Datatype,
    "Datatypes": Datatypes,
    "Endpoint": Endpoint,
    "EndpointObject": EndpointObject,
    "EndpointObjects": EndpointObjects,
    "Endpoints": Endpoints,
    "Job": Job,
    "Jobs": Jobs,
    "Log": Log,
    "Logs": Logs,
    "Mandator": Mandator,
    "Mandators": Mandators,
    "ObjectRelative": ObjectRelative,
    "ObjectRelatives": ObjectRelatives,
    "Processes": Processes,
    "Workflow": Workflow,
    "Workflows": Workflows,
    "LdapEndpoint": LdapEndpoint,
    "MysqlEndpoint": MysqlEndpoint,
    "PdoEndpoint": PdoEndpoint,
    "Process": Process,
    "RestEndpoint": RestEndpoint,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccessRolesApiApiKeys {
}

export class AccessRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessRolesApiApiKeys, value: string) {
        (this.authentications as any)[AccessRolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new access role
     * @param data 
     */
    public addAccessRole (data?: AccessRole) : any {
        const localVarPath = this.basePath + '/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-role by name
     * @param access_role Access role name
     */
    public deleteAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling deleteAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access role by name
     * @param access_role Access role name
     */
    public getAccessRole (access_role: string) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling getAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access role defines what role is granted access to what resource
     * @summary Get access roles
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getAccessRoles (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRoles".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access role
     * @param access_role Access role name
     * @param data 
     */
    public replaceAccessRole (access_role: string, data?: AccessRole) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling replaceAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRole")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access role as rfc6902 request
     * @param access_role Access role name
     * @param job Access role json patch
     */
    public updateAccessRole (access_role: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/access-roles/{access-role}'
            .replace('{' + 'access-role' + '}', encodeURIComponent(String(access_role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_role' is not null or undefined
        if (access_role === null || access_role === undefined) {
            throw new Error('Required parameter access_role was null or undefined when calling updateAccessRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateAccessRole".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch access roles
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchAccessRoles (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/access-roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchAccessRoles".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccessRulesApiApiKeys {
}

export class AccessRulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessRulesApiApiKeys, value: string) {
        (this.authentications as any)[AccessRulesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new access rule
     * @param data 
     */
    public addAccessRule (data?: AccessRule) : any {
        const localVarPath = this.basePath + '/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete access-rule by name
     * @param access_rule Access rule name
     */
    public deleteAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling deleteAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get access rule by name
     * @param access_rule Access rule name
     */
    public getAccessRule (access_rule: string) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling getAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An access rule defines what role is granted access to what resource
     * @summary Get access rules
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getAccessRules (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getAccessRules".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRules;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace an access rule
     * @param access_rule Access rule name
     * @param data 
     */
    public replaceAccessRule (access_rule: string, data?: AccessRule) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling replaceAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "AccessRule")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Patch access rule as rfc6902 request
     * @param access_rule Access rule name
     * @param job Access rule json patch
     */
    public updateAccessRule (access_rule: string, job?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/access-rules/{access-rule}'
            .replace('{' + 'access-rule' + '}', encodeURIComponent(String(access_rule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'access_rule' is not null or undefined
        if (access_rule === null || access_rule === undefined) {
            throw new Error('Required parameter access_rule was null or undefined when calling updateAccessRule.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(job, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateAccessRule".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: AccessRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch access rules
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchAccessRules (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/access-rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchAccessRules".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataApiApiKeys {
}

export class DataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DataApiApiKeys, value: string) {
        (this.authentications as any)[DataApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new object of a specifc datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data 
     */
    public addObject (mandator: string, datatype: string, data?: DataObject) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new object relation to an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param data 
     */
    public addObjectRelative (mandator: string, datatype: string, object: string, data?: ObjectRelative) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling addObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "ObjectRelative")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a specific object
     * @summary Delete object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     */
    public deleteObject (mandator: string, datatype: string, object: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete object relation
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     */
    public deleteObjectRelative (mandator: string, datatype: string, object: string, relative: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling deleteObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling deleteObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get objects from endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getEndpointObjects (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpointObjects.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpointObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpointObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: EndpointObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EndpointObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an object of a specific datatype
     * @summary Get specific object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param attributes Filter attributes
     */
    public getObject (mandator: string, datatype: string, object: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObject.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the history of all modifications from a specific object
     * @summary Get object history
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getObjectHistory (mandator: string, datatype: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/history'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectHistory.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectHistory.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectHistory".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single relative object of an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     */
    public getObjectRelative (mandator: string, datatype: string, object: string, relative: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling getObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all objects the object is related to
     * @summary Get relative objects of an object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getObjectRelatives (mandator: string, datatype: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjectRelatives.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjectRelatives.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling getObjectRelatives.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjectRelatives".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelatives;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelatives");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A object is a data object from a specifc datatype
     * @summary Get objects of a specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getObjects (mandator: string, datatype: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace all data attributes of an object (Or create one if not exists)
     * @summary Replace or create object
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param write If true, the objects gets synced to all configured destination endpoints
     * @param data 
     */
    public replaceObject (mandator: string, datatype: string, object: string, write?: boolean, data?: DataObject) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling replaceObject.');
        }

        if (write !== undefined) {
            localVarQueryParameters['write'] = ObjectSerializer.serialize(write, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "DataObject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of an object
     * @summary Patch object as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param data Object
     */
    public updateObject (mandator: string, datatype: string, object: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateObject.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateObject.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateObject".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: DataObject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataObject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update object relation
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param relative Object ID
     * @param data 
     */
    public updateObjectRelative (mandator: string, datatype: string, object: string, relative: string, data?: ObjectRelative) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives/{relative}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)))
            .replace('{' + 'relative' + '}', encodeURIComponent(String(relative)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling updateObjectRelative.');
        }

        // verify required parameter 'relative' is not null or undefined
        if (relative === null || relative === undefined) {
            throw new Error('Required parameter relative was null or undefined when calling updateObjectRelative.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "ObjectRelative")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateObjectRelative".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ObjectRelative;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ObjectRelative");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch datatypes in realtime
     * @summary Watch datatypes
     * @param mandator Mandator name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchDatatypes (mandator: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchDatatypes.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchDatatypes".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch endpoints
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchEndpoints (mandator: string, datatype: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchEndpoints.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchEndpoints".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch mandators in realtime
     * @summary Watch mandators
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchMandators (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchMandators".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch object relatives
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param object Object ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchObjectRelatives (mandator: string, datatype: string, object: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/objects/{object}/relatives'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'object' + '}', encodeURIComponent(String(object)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchObjectRelatives.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchObjectRelatives.');
        }

        // verify required parameter 'object' is not null or undefined
        if (object === null || object === undefined) {
            throw new Error('Required parameter object was null or undefined when calling watchObjectRelatives.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchObjectRelatives".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch objects
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchObjects (mandator: string, datatype: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/objects'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchObjects.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchObjects.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchObjects".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch updates in realtime
     * @summary Watch workflows
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchWorkflows (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling watchWorkflows.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling watchWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling watchWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchWorkflows".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DatatypesApiApiKeys {
}

export class DatatypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DatatypesApiApiKeys, value: string) {
        (this.authentications as any)[DatatypesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add datatype
     * @param mandator Mandator name
     * @param data 
     */
    public addDatatype (mandator: string, data?: Datatype) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Datatype")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     */
    public deleteDatatype (mandator: string, datatype: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A datatype is collection of dataobjects of a specific type
     * @summary Get specific datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param attributes Filter attributes
     */
    public getDatatype (mandator: string, datatype: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getDatatype.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A datatype is collection of data objects of a specific type
     * @summary Get datatypes
     * @param mandator Mandator name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getDatatypes (mandator: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getDatatypes.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getDatatypes".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatypes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatypes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace datatype
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data 
     */
    public replaceDatatype (mandator: string, datatype: string, data?: Datatype) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Datatype")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a datatype
     * @summary Patch datatype as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data Datatype
     */
    public updateDatatype (mandator: string, datatype: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateDatatype.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateDatatype.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateDatatype".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Datatype;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datatype");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get api entrypoint
     */
    public root () : any {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("root".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EndpointsApiApiKeys {
}

export class EndpointsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EndpointsApiApiKeys, value: string) {
        (this.authentications as any)[EndpointsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add Endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param data 
     */
    public addEndpoint (mandator: string, datatype: string, data?: any) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     */
    public deleteEndpoint (mandator: string, datatype: string, endpoint: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get specific endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param attributes Filter attributes
     */
    public getEndpoint (mandator: string, datatype: string, endpoint: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getEndpoint.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An endpoint is either of type source or destination and defines an import/export destination
     * @summary Get endpoints
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getEndpoints (mandator: string, datatype: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getEndpoints.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getEndpoints.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getEndpoints".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace endppoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data 
     */
    public replaceEndpoint (mandator: string, datatype: string, endpoint: string, data?: Endpoint) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Endpoint")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a endpoint
     * @summary Patch datatype as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data Datatype
     */
    public updateEndpoint (mandator: string, datatype: string, endpoint: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateEndpoint.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateEndpoint.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateEndpoint".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Endpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Endpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum JobsApiApiKeys {
}

export class JobsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: JobsApiApiKeys, value: string) {
        (this.authentications as any)[JobsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create new job
     * @param data 
     */
    public addJob (data?: Job) : any {
        const localVarPath = this.basePath + '/jobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Job")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Trigger a new process
     * @param data 
     */
    public addProcess (data?: Process) : any {
        const localVarPath = this.basePath + '/processes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Process")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addProcess".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete job by id
     * @param job Job ID
     */
    public deleteJob (job: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling deleteJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Abort running process
     * @param process Process ID
     */
    public deleteProcess (process: string) : any {
        const localVarPath = this.basePath + '/processes/{process}'
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling deleteProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteProcess".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get job by id
     * @param job Job ID
     */
    public getJob (job: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single job error
     * @param job Job ID
     * @param log Log id
     */
    public getJobLog (job: string, log: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}/logs/{log}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getJobLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobLog".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a job
     * @param job Job ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getJobLogs (job: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/jobs/{job}/logs'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling getJobLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobLogs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A job is an asynchronous server process
     * @summary Get list of active queued jobs
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getJobs (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/jobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getJobs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Jobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Jobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process of a job
     * @param process Process ID
     */
    public getProcess (process: string) : any {
        const localVarPath = this.basePath + '/processes/{process}'
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getProcess".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Process;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Process");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single process log
     * @param process Process ID
     * @param log Log id
     */
    public getProcessLog (process: string, log: string) : any {
        const localVarPath = this.basePath + '/process/{process}/logs/{log}'
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)))
            .replace('{' + 'log' + '}', encodeURIComponent(String(log)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLog.');
        }

        // verify required parameter 'log' is not null or undefined
        if (log === null || log === undefined) {
            throw new Error('Required parameter log was null or undefined when calling getProcessLog.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getProcessLog".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs of a process
     * @param process Process ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getProcessLogs (process: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/processes/{process}/logs'
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling getProcessLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getProcessLogs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Log;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Log");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all processes
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getProcesses (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/processes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getProcesses".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Processes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Processes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a job
     * @summary Patch job as rfc6902 request
     * @param job Job ID
     * @param data Object
     */
    public updateJob (job: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/jobs/{job}'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling updateJob.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateJob".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Job;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Job");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Watch log stream
     * @param job Job ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchJobLogs (job: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/jobs/{job}/logs'
            .replace('{' + 'job' + '}', encodeURIComponent(String(job)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'job' is not null or undefined
        if (job === null || job === undefined) {
            throw new Error('Required parameter job was null or undefined when calling watchJobLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchJobLogs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A job is an asynchronous server process
     * @summary Get realtime updates
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchJobs (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/jobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchJobs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Watch log stream
     * @param process Process ID
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchProcessLogs (process: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/processes/{process}/logs'
            .replace('{' + 'process' + '}', encodeURIComponent(String(process)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'process' is not null or undefined
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling watchProcessLogs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchProcessLogs".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Watch job processes
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public watchProcesses (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/watch/processes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("watchProcesses".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MandatorsApiApiKeys {
}

export class MandatorsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MandatorsApiApiKeys, value: string) {
        (this.authentications as any)[MandatorsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add mandator
     * @param data 
     */
    public addMandator (data?: Mandator) : any {
        const localVarPath = this.basePath + '/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Mandator")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific mandator
     * @param mandator Mandator name
     */
    public deleteMandator (mandator: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteMandator.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A mandator is a logical group of datatypes
     * @summary Get specific mandator
     * @param mandator Mandator name
     * @param attributes Filter attributes
     */
    public getMandator (mandator: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getMandator.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A mandator is a logical group of datatypes
     * @summary Get mandators
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getMandators (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getMandators".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandators;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandators");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace mandator
     * @param mandator Mandator name
     * @param data 
     */
    public replaceMandator (mandator: string, data?: Mandator) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceMandator.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Mandator")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a mandator
     * @summary Patch mandator as rfc6902 request
     * @param mandator Mandator name
     * @param data Mandator
     */
    public updateMandator (mandator: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateMandator.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateMandator".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Mandator;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mandator");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WorkflowsApiApiKeys {
}

export class WorkflowsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WorkflowsApiApiKeys, value: string) {
        (this.authentications as any)[WorkflowsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add worfklow to endpoint
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param data 
     */
    public addWorkflow (mandator: string, datatype: string, endpoint: string, data?: Workflow) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling addWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling addWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("addWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific workflow from
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     */
    public deleteWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling deleteWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling deleteWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("deleteWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a datatype and with what attribute map
     * @summary Get specifc endpoint workflow
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param attributes Filter attributes
     */
    public getWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling getWorkflow.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A workflow is an action how to import/export a datatype and with what attribute map
     * @summary Get endpoint workflows
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getWorkflows (mandator: string, datatype: string, endpoint: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling getWorkflows.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling getWorkflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("getWorkflows".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflows;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflows");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or replace workflow
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data 
     */
    public replaceWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, data?: Workflow) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling replaceWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling replaceWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Workflow")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("replaceWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific attributes of a workflow
     * @summary Patch workflow as rfc6902 request
     * @param mandator Mandator name
     * @param datatype Datatype
     * @param endpoint Endpoint name
     * @param workflow Workflow name
     * @param data Workflow
     */
    public updateWorkflow (mandator: string, datatype: string, endpoint: string, workflow: string, data?: Array<JsonPatch>) : any {
        const localVarPath = this.basePath + '/mandators/{mandator}/datatypes/{datatype}/endpoints/{endpoint}/workflows/{workflow}'
            .replace('{' + 'mandator' + '}', encodeURIComponent(String(mandator)))
            .replace('{' + 'datatype' + '}', encodeURIComponent(String(datatype)))
            .replace('{' + 'endpoint' + '}', encodeURIComponent(String(endpoint)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mandator' is not null or undefined
        if (mandator === null || mandator === undefined) {
            throw new Error('Required parameter mandator was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'datatype' is not null or undefined
        if (datatype === null || datatype === undefined) {
            throw new Error('Required parameter datatype was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling updateWorkflow.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling updateWorkflow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<JsonPatch>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if("updateWorkflow".match('^watch[A-Z]')) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Workflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
